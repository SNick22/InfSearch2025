<!DOCTYPE html>
<html lang="ru">

  <head>
    <title>Практика по Котлину: Создание веб приложений на React и Kotlin&#x2F;JS &#x2F; Хабр</title>
<meta property="fb:app_id" content="444736788986613">
<meta property="fb:pages" content="472597926099084">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@habr_com">
<meta property="og:site_name" content="Хабр">
<link href="https://habr.com/ru/rss/post/555744/?fl=ru" type="application/rss+xml" title rel="alternate" name="rss">
<link href="https://habr.com/ru/articles/555744/" rel="canonical" data-hid="e3fa780">
<link rel="image_src" href="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/" data-hid="2a79c45">
<meta property="og:title" content="Практика по Котлину: Создание веб приложений на React и Kotlin/JS">
<meta name="twitter:title" content="Практика по Котлину: Создание веб приложений на React и Kotlin/JS">
<meta name="aiturec:title" content="Практика по Котлину: Создание веб приложений на React и Kotlin/JS">
<meta name="description" content="От переводчика . Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ ( JVM , JS ,...">
<meta itemprop="description" content="От переводчика . Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ ( JVM , JS ,...">
<meta property="og:description" content="От переводчика . Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ ( JVM , JS ,...">
<meta name="twitter:description" content="От переводчика . Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ ( JVM , JS ,...">
<meta property="aiturec:description" content="От переводчика . Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ ( JVM , JS ,...">
<meta itemprop="image" content="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/">
<meta property="og:image" content="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="aiturec:image" content="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/">
<meta name="twitter:image" content="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/">
<meta property="vk:image" content="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/?format=vk">
<meta property="vk:image" content="https://habr.com/share/publication/555744/e77692b1636232590f60dbc7b84ae70f/?format=vk?format=vk">
<meta property="aiturec:item_id" content="555744">
<meta property="aiturec:datetime" content="2021-05-04T16:37:44.000Z">
<meta content="https://habr.com/ru/articles/555744/" property="og:url">
<meta property="og:type" content="article">
<meta property="og:locale" content="ru_RU">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta name="keywords" content="javascript, reactjs, kotlin">
<script type="application/ld+json" data-hid="1e0f0a2">{"@context":"http:\/\/schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/habr.com\/ru\/articles\/555744\/"},"headline":"Практика по Котлину: Создание веб приложений на React и Kotlin\/JS","datePublished":"2021-05-04T19:37:44+03:00","dateModified":"2021-05-04T20:55:46+03:00","author":{"@type":"Person","name":"SerVB"},"publisher":{"@type":"Organization","name":"Habr","logo":{"@type":"ImageObject","url":"https:\/\/habrastorage.org\/webt\/a_\/lk\/9m\/a_lk9mjkccjox-zccjrpfolmkmq.png"}},"description":"От переводчика. Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерж...","url":"https:\/\/habr.com\/ru\/articles\/555744\/#post-content-body","about":["h_javascript","h_kotlin","h_reactjs","h_web_design","h_webdev","f_develop","f_design"],"image":["https:\/\/habrastorage.org\/getpro\/habr\/post_images\/e82\/357\/ada\/e82357ada36198277e49b1ad14a830bc.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/e98\/63c\/4b8\/e9863c4b8f99d4ae60691fbf15bfe1a8.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/897\/290\/973\/897290973b762d0318e9a62b3971a221.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/dc2\/12f\/22f\/dc212f22f7b4bd36e6d18600f87ef77a.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/81c\/a95\/32c\/81ca9532c243740abf29334207164d52.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/275\/194\/45d\/27519445d08e39e965416a2db3c07892.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/ada\/0a2\/550\/ada0a25506506187b003da6597154be9.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/aff\/20b\/47c\/aff20b47c153c8002fea293f13976a4b.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/f70\/411\/691\/f70411691aa04c00591ceefbeda5b3d9.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/a5f\/b36\/ef7\/a5fb36ef7172f53642a2e5364fb19319.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/07f\/85e\/867\/07f85e8677b33e952fdc2734aee60e95.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/188\/255\/3e3\/1882553e39a1d6e05dc7f3b637e2bb9d.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/1b8\/38d\/927\/1b838d92717d355eb47cdc830848afad.png","https:\/\/habrastorage.org\/getpro\/habr\/post_images\/29c\/72a\/caa\/29c72acaab8d818c7251d70c01313088.png"]}</script>
    <meta charset="UTF-8">
    <meta name="viewport"
      content="width=device-width,initial-scale=1.0,viewport-fit=cover,maximum-scale=1,user-scalable=0">
    <meta name="referrer" content="unsafe-url">
    <style>
      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5VvmojLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5Vvk4jLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5VvmYjLazX3dGTP.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9E4kDNxMZdWfMOD5Vvl4jLazX3dA.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }

      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveSxf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveQhf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveSBf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 500;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnZKveRhf6Xl7Glw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }

      /* cyrillic-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eSxf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
      }

      /* cyrillic */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eQhf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
      }

      /* latin-ext */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eSBf6Xl7Gl3LX.woff2) format('woff2');
        unicode-range: U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
      }

      /* latin */
      @font-face {
        font-family: 'Fira Sans';
        font-style: normal;
        font-weight: 700;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/firasans/v17/va9B4kDNxMZdWfMOD5VnLK3eRhf6Xl7Glw.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
    </style>
    <link rel="preload" href="https://assets.habr.com/habr-web/css/theme/light-v1.css" as="style" media="(prefers-color-scheme: light)" /><link rel="preload" href="https://assets.habr.com/habr-web/css/theme/dark-v1.css" as="style" media="(prefers-color-scheme: dark)" /><link id="light-colors" rel="stylesheet" href="https://assets.habr.com/habr-web/css/theme/light-v1.css" media="(prefers-color-scheme: light)" /><link id="dark-colors" rel="stylesheet" href="https://assets.habr.com/habr-web/css/theme/dark-v1.css" media="(prefers-color-scheme: dark)" />
    <script>window.i18nFetch = new Promise((res, rej) => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', '/js/i18n/ru-compiled.35b2fec11bb79a62419ab67779c2dd82.json');
          xhr.responseType = 'json';
          xhr.onload = function(e) {
            if (this.status === 200) {
              res({ru: xhr.response});
            } else {
              rej(e);
            }
          };
          xhr.send();
        });</script>
    <style>
      .grecaptcha-badge {
        visibility: hidden;
      }
    </style>
    <meta name="habr-version" content="2.233.0">
    
    <meta name="apple-mobile-web-app-status-bar-style" content="#303b44">
    <meta name="msapplication-TileColor" content="#629FBC">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <link rel="shortcut icon" type="image/png" sizes="16x16" href="https://assets.habr.com/habr-web/img/favicons/favicon-16.png">
    <link rel="shortcut icon" type="image/png" sizes="32x32" href="https://assets.habr.com/habr-web/img/favicons/favicon-32.png">
    <link rel="apple-touch-icon" type="image/png" sizes="76x76" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-76.png">
    <link rel="apple-touch-icon" type="image/png" sizes="120x120" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.png">
    <link rel="apple-touch-icon" type="image/png" sizes="152x152" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-152.png">
    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-180.png">
    <link rel="apple-touch-icon" type="image/png" sizes="256x256" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-256.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1136x640.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2436x1125.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1792x828.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_828x1792.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1334x750.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2668.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2208x1242.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1125x2436.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1242x2208.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2732x2048.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2688x1242.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2224x1668.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_750x1334.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2048x2732.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2388x1668.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2224.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_640x1136.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1668x2388.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_2048x1536.png">
    <link rel="apple-touch-startup-image"
      media="screen and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"
      href="https://assets.habr.com/habr-web/img/splashes/splash_1536x2048.png">
    <link rel="mask-icon" color="#77a2b6" href="https://assets.habr.com/habr-web/img/favicons/apple-touch-icon-120.svg">
    <link crossorigin="use-credentials" href="/manifest.webmanifest" rel="manifest">
    <script async src="https://unpkg.com/pwacompat" crossorigin="anonymous"></script>
    <script>window.yaContextCb = window.yaContextCb || []</script>
    <script src="https://yandex.ru/ads/system/context.js" async></script>
  <link rel="preload" href="https://assets.habr.com/habr-web/css/chunk-vendors.04465f7c.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/chunk-vendors.3b11d41f.js" as="script"><link rel="preload" href="https://assets.habr.com/habr-web/css/app.20959a76.css" as="style"><link rel="preload" href="https://assets.habr.com/habr-web/js/app.7a97ea6d.js" as="script"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/chunk-vendors.04465f7c.css"><link rel="stylesheet" href="https://assets.habr.com/habr-web/css/app.20959a76.css"></head>
  <body>
    
    <div id="mount"><div id="app" data-async-called="true"><div class="tm-layout__wrapper"><!--[--><!----><div></div><div class="tm-feature tm-feature"><!----></div><header class="tm-header" data-test-id="header"><div class="tm-page-width"><!--[--><div class="tm-header__container"><div class="tm-header__burger-nav" data-test-id="burger-nav"><button class="tm-header__button tm-header__button_burger" type="button"><svg class="tm-svg-img tm-header__icon tm-header__icon-burger" height="16" width="16"><title>Меню</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#header-burger"></use></svg></button></div><span class="tm-header__logo-wrap"><a class="tm-header__logo tm-header__logo_hl-ru tm-header__logo" href="/ru/"><svg class="tm-svg-img tm-header__icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a><span style="display:none;" class="tm-header__beta-sign">β</span></span><!----><div class="tm-header-user-menu tm-header_user-menu"><a href="/ru/search/" class="tm-header-user-menu__item tm-header-user-menu__search" data-test-id="search-button"><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_search" height="24" width="24"><title>Поиск</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#search"></use></svg></a><!----><!----><div class="tm-header-user-menu__item tm-header-user-menu__write"><div><svg class="tm-svg-img tm-header-user-menu__icon tm-header-user-menu__icon_write" height="24" width="24"><title>Написать публикацию</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#write"></use></svg></div><!----></div><!--[--><div class="tm-header-user-menu__item"><button class="tm-header-user-menu__toggle" data-test-id="user-menu-settings"><svg class="tm-svg-img tm-header-user-menu__icon" height="24" width="24"><title>Настройки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#page-settings"></use></svg></button></div><a href="https://habr.com/kek/v1/auth/habrahabr/?back=/ru/articles/555744/&amp;hl=ru" rel="nofollow" class="tm-header-user-menu__item"><!--[--><button class="btn btn_solid btn_small tm-header-user-menu__login" type="button"><!--[-->Войти<!--]--></button><!--]--></a><!--]--><!----><!--teleport start--><!--teleport end--><!----></div></div><!--]--></div></header><div class="tm-layout"><div class="tm-page-progress-bar"></div><!----><!----><div class="tm-page-width"><!--[--><!--]--></div><main class="tm-layout__container"><div class="tm-page" hl="ru" data-async-called="true" style="--0c809c5a:16px;--a086013e:100%;--7c457026:0;"><div class="tm-page-width"><!--[--><!----><div class="tm-page__wrapper"><div class="tm-page__main_has-sidebar tm-page__main"><div class="pull-down"><!----><div class="pull-down__header" style="height:0px;"><div class="pull-down__content" style="bottom:10px;"><svg class="tm-svg-img pull-down__icon pull-down__arrow" height="24" width="24"><title>Обновить</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#pull-arrow"></use></svg></div></div><!--[--><!--[--><div class="banner-wrapper narrow" style="--467224fc:100px;--58ff5eba:auto;" data-v-ad758baa><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="adfox-banner-placeholder narrow" data-v-12f7bcca><div class="image loads" data-v-12f7bcca></div><div class="lines" data-v-12f7bcca><div class="line loads" data-v-12f7bcca></div><div class="line loads" data-v-12f7bcca></div><div class="line loads" data-v-12f7bcca></div></div></div><!----></div><div id="adfox_169815559787254866" class="tm-adfox-banner" data-v-ad758baa></div><!--]--></div><div class="tm-article-presenter"><!--[--><!--]--><div class="tm-article-presenter__body" data-test-id="article-body"><div class="tm-misprint-area"><div class="tm-misprint-area__wrapper"><!--[--><article class="tm-article-presenter__content tm-article-presenter__content_narrow"><!--[--><div class="tm-article-presenter__header"><!--[--><!--]--><div class="tm-article-snippet tm-article-snippet tm-article-presenter__snippet"><!--[--><!--]--><div class="tm-article-snippet__meta-container"><div class="tm-article-snippet__meta"><span class="tm-user-info tm-article-snippet__author"><a href="/ru/users/SerVB/" class="tm-user-info__userpic" data-test-id="user-info-pic" title="SerVB"><div class="tm-entity-image"><!--[--><img alt="" class="tm-entity-image__pic" height="32" src="https://assets.habr.com/habr-web/img/avatars/051.png" width="32"><!--]--></div></a><span class="tm-user-info__user tm-user-info__user_appearance-default" data-test-id="user-info-description"><a href="/ru/users/SerVB/" class="tm-user-info__username">SerVB <!----></a><!--[--><span class="tm-article-datetime-published"><time datetime="2021-05-04T16:37:44.000Z" title="2021-05-04, 19:37">4  мая  2021 в 19:37</time></span><!--]--></span></span></div><!----></div><h1 class="tm-title tm-title_h1" lang="ru" data-test-id="articleTitle"><span>Практика по Котлину: Создание веб приложений на React и Kotlin/JS</span></h1><div class="tm-article-snippet__stats" data-test-id="articleStats"><!----><div class="tm-article-reading-time"><span class="tm-svg-icon__wrapper tm-article-reading-time__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Время на прочтение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#clock"></use></svg></span><span class="tm-article-reading-time__label">38 мин</span></div><span class="tm-icon-counter tm-data-icons__item"><svg class="tm-svg-img tm-icon-counter__icon" height="24" width="24"><title>Количество просмотров</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-views"></use></svg><span class="tm-icon-counter__value" title="28874">29K</span></span></div><div class="tm-publication-hubs__container" data-test-id="articleHubsList"><div class="tm-publication-hubs"><!--[--><span class="tm-publication-hub__link-container"><a href="/ru/hubs/javascript/" class="tm-publication-hub__link"><!--[--><span>JavaScript</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/kotlin/" class="tm-publication-hub__link"><!--[--><span>Kotlin</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/reactjs/" class="tm-publication-hub__link"><!--[--><span>ReactJS</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/web_design/" class="tm-publication-hub__link"><!--[--><span>Веб-дизайн</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><span class="tm-publication-hub__link-container"><a href="/ru/hubs/webdev/" class="tm-publication-hub__link"><!--[--><span>Веб-разработка</span><span class="tm-article-snippet__profiled-hub" title="Профильный хаб">*</span><!--]--></a></span><!--]--></div></div><div class="tm-article-labels" data-test-id="articleLabels"><div class="tm-article-labels__container"><div class="tm-publication-label tm-publication-label_variant-tutorial"><span>Туториал</span></div><!--[--><div class="tm-publication-label tm-publication-label_variant-translation"><span>Перевод</span></div><!--]--></div></div><!----><!----></div></div><!--[--><div class="tm-article-presenter__origin"><a class="tm-article-presenter__origin-link" href="https://play.kotlinlang.org/hands-on/Building%2520Web%2520Applications%2520with%2520React%2520and%2520Kotlin%2520JS/01_Introduction" target="_blank">Автор оригинала: <span>JetBrains – Kotlin Team</span></a></div><div class="tm-article-body" data-gallery-root lang="ru"><div><!--[--><!--]--></div><div id="post-content-body"><div><div class="article-formatted-body article-formatted-body article-formatted-body_version-1"><div xmlns="http://www.w3.org/1999/xhtml"><p><em>От переводчика</em>.</p><br/>
<p>Привет! Про <strong>Kotlin</strong> есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ (<strong>JVM</strong>, <strong>JS</strong>, <strong>Native</strong>), а также умеет работать с библиотеками для этих платформ, написанных на других языках. Такая поддержка "мультиплатформенности" позволяет не только писать всевозможные проекты на одном языке в единой форме, но и переиспользовать код при написании одного проекта под разные платформы.</p><br/>
<p>В этой статье я перевожу <a href="https://play.kotlinlang.org/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS" rel="nofollow noopener noreferrer">официальный туториал Kotlin Hands-On</a> о создании веб сайтов на Котлине. Мы рассмотрим многие аспекты программирования на Kotlin/JS и поймем, как работать не только с чистым DOM. В основном будем говорить о <a href="https://reactjs.org/" rel="nofollow noopener noreferrer">React JS</a>, но также коснемся системы сборки <strong>Gradle</strong>, использования зависимостей из <strong>NPM</strong>, обращения к <strong>REST API</strong>, деплоя на <strong>Heroku</strong>, и в итоге сделаем <em>приложение-видеоплеер</em>.</p><br/>
<p>Текст ориентирован на тех, кто немного знает Котлин и не знает или почти не знает Реакт. Если вы более опытны по этим вопросам, то части туториала могут показаться вам чрезмерно разжеванными.</p><br/>
<p><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/e82/357/ada/e82357ada36198277e49b1ad14a830bc.png" alt="kotlin-react" data-src="https://habrastorage.org/getpro/habr/post_images/e82/357/ada/e82357ada36198277e49b1ad14a830bc.png"/></p><a name="habracut"></a><br/>
<p>Надеюсь, статья удовлетворит <a href="https://habr.com/ru/company/productsense/blog/526238/#comment_22257922">пусть даже непопулярные запросы</a> на материалы о Котлине на русском.</p><br/>
<p>Предлагать правки в эту статью лучше всего <a href="https://github.com/SerVB/kotlin-hands-on-ru/edit/master/hands-on/Building%20Web%20Applications%20with%20React%20and%20Kotlin%20JS.md" rel="nofollow noopener noreferrer">на ГитХабе</a>. Текущий перевод построен на версии оригинального туториала, актуальной на 09.04.2021.</p><br/>
<h2 id="soderzhanie">Содержание</h2><br/>
<ol>
<li><a href="#a-namestep1shag-1-vvedeniea">Введение</a></li>
<li><a href="#a-namestep2shag-2-nastroykaa">Настройка</a></li>
<li><a href="#a-namestep3shag-3-pervaya-stranica-na-reakte--statichnayaa">Первая страница на Реакте – статичная</a></li>
<li><a href="#a-namestep4shag-4-react--o-reakciyah-nash-pervyy-komponenta">React – о реакциях. Наш первый компонент</a></li>
<li><a href="#a-namestep5shag-5-rabotaem-sovmestno-kompoziciya-komponentova">Работаем совместно. Композиция компонентов</a></li>
<li><a href="#a-namestep6shag-6-bolshe-komponentova">Больше компонентов!</a></li>
<li><a href="#a-namestep7shag-7-ispolzovanie-npm-paketova">Использование NPM пакетов</a></li>
<li><a href="#a-namestep8shag-8-ispolzuem-vneshnee-rest-apia">Используем внешнее REST API</a></li>
<li><a href="#a-namestep9shag-9-deploim-v-prodakshen-i-v-oblakoa">Деплоим в продакшен и в облако</a></li>
<li><a href="#a-namestep10shag-10-v-dopolnenie-sovremennyy-reakt-s-hukamia">В дополнение: современный Реакт с хуками</a></li>
<li><a href="#a-namestep11shag-11-chto-dalshea">Что дальше?</a></li>
</ol><br/>
<h2 id="a-namestep1shag-1-vvedeniea">Шаг 1. Введение</h2><br/>
<p>На этой практике мы рассмотрим, как использовать Kotlin/JS вместе с популярным фреймворком <a href="https://reactjs.org/" rel="nofollow noopener noreferrer">React</a> для создания красивых и поддерживаемых браузерных приложений. React позволяет создавать веб приложения современно и структурировано, фокусируясь на переиспользовании компонентов и на особом способе управления состоянием приложения. Он имеет большую экосистему материалов и компонентов, созданную сообществом.</p><br/>
<p>Использование Котлина для написания приложений на React позволяет опираться на наши знания о парадигмах, синтаксисе и инструментах этого языка при создании фронт-энд приложений для современных браузеров. А еще использовать котлиновские библиотеки одновременно с возможностями платформы и экосистемы JavaScript.</p><br/>
<p>На этой практике мы научимся создавать приложение на Kotlin/JS и React, используя Gradle плагин <code>org.jetbrains.kotlin.js</code>. Мы решим задачи, обычно возникающие при создании типичного простого React приложения.</p><br/>
<p>Мы узнаем, как <em>предметно-ориентированные языки</em> (<em>DSL</em>) помогают выражать идеи кратким и единообразным способом без жертв читаемости, давая возможность написать полноценное приложение полностью на Котлине. Также мы покажем, как использовать уже сделанные сообществом компоненты и библиотеки, и как опубликовать получившееся приложение.</p><br/>
<p>Предполагается, что у вас уже есть базовое понимание Котлина, и <em>совсем поверхностное</em> знание HTML и CSS. Базовое знание идей Реакта будет полезным для понимания примеров кода, но не обязательно.</p><br/>
<h3 id="chto-imenno-my-sozdadim">Что именно мы создадим</h3><br/>
<p>Ежегодное событие <a href="https://kotlinconf.com/" rel="nofollow noopener noreferrer">KotlinConf</a> стоит посетить, если вы хотите узнать больше о Котлине и пообщаться с сообществом. KotlinConf 2018 предлагал огромное количество информации в виде мастер-классов и лекций и насчитывал 1300 участников. Доклады публично доступны на YouTube, и поклонникам Котлина было бы полезно <strong>увидеть</strong> перечень докладов на одной странице и <strong>помечать</strong> их как <em>просмотренные</em> – идеально для погружения в Котлин "запоем". На этой практике мы как раз создадим такое приложение – <em>KotlinConf Explorer</em> (см. скриншот ниже).</p><br/>
<p><img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/e98/63c/4b8/e9863c4b8f99d4ae60691fbf15bfe1a8.png" alt="Результат" data-src="https://habrastorage.org/getpro/habr/post_images/e98/63c/4b8/e9863c4b8f99d4ae60691fbf15bfe1a8.png"/></p><br/>
<p>Исходный код финального приложения, как и промежуточные результаты, можно найти <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle" rel="nofollow noopener noreferrer">в репозитории</a> на GitHub. Результат каждого шага доступен в соответствующей ветке, ссылки на которые мы дополнительно дублируем в конце каждого параграфа.</p><br/>
<p>Начнем с настройки среды разработки и установки инструментов, которые помогут нам в работе.</p><br/>
<h2 id="a-namestep2shag-2-nastroykaa">Шаг 2. Настройка</h2><br/>
<h3 id="prerekvizity">Пререквизиты</h3><br/>
<p>Чтобы начать, давайте убедимся, что у вас установлена актуальная среда разработки. Вот все, что нам нужно сейчас – это IntelliJ IDEA (версии <code>2020.3</code> или новее, достаточно бесплатной Community Edition) с плагином Котлин (<code>1.4.30</code> или новее) – скачать можно <a href="https://www.jetbrains.com/idea/download/" rel="nofollow noopener noreferrer">по ссылке</a>. Выберите установочный файл, соответствующий вашей ОС (поддерживаются Windows, MacOS и Linux).</p><br/>
<h3 id="sozdaem-proekt">Создаем проект</h3><br/>
<p>Для этой практики мы подготовили стартовый шаблон проекта, включающий все настройки и зависимости.</p><br/>
<p>Склонируйте <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle" rel="nofollow noopener noreferrer">этот GitHub репозиторий</a> и откройте его с помощью IntelliJ IDEA (например, с помощью <strong>File | New | Project from Version Control...</strong> или <strong>Git | Clone...</strong>).</p><br/>
<p>Этот шаблон содержит простейший Kotlin/JS Gradle проект, на основе которого можно делать что-то свое. Так как в Gradle конфигурации шаблона уже прописаны все необходимые для практики зависимости, <strong>вам не придется изменять ее</strong>.</p><br/>
<p>В любом случае полезно понимать, какие артефакты используются для приложения, так что давайте посмотрим повнимательнее на шаблонные зависимости и конфигурации.</p><br/>
<p><strong>Примечание от переводчика</strong>: конечно, для будущих проектов можно начинать как с шаблона, так и с пустого Gradle проекта, добавляя только нужные зависимости – для этого как раз и предстоит с ними разобраться.</p><br/>
<h4 id="zavisimosti-i-zadachi-gradle">Зависимости и задачи Gradle</h4><br/>
<p>На практике мы будем использовать React, некоторые другие внешние зависимости, а еще котлиновские библиотеки. Чтобы не тратить время на импортирование изменений Gradle скриптов на каждом шаге, мы добавляем все зависимости в самом начале.</p><br/>
<p>Для начала давайте убедимся, что внутри файла <code>build.gradle.kts</code> есть блок <code>repositories</code>. Таким образом объявляются источники зависимостей.</p><br/>
<p>Блок зависимостей <code>dependencies</code> содержит все нужные для практики внешние библиотеки:</p><br/>
<pre><code class="kotlin">dependencies {
    // React, React DOM + Wrappers (шаг 3)
    implementation("org.jetbrains:kotlin-react:17.0.1-pre.148-kotlin-1.4.21")
    implementation("org.jetbrains:kotlin-react-dom:17.0.1-pre.148-kotlin-1.4.21")
    implementation(npm("react", "17.0.1"))
    implementation(npm("react-dom", "17.0.1"))

    // Kotlin Styled (шаг 3)
    implementation("org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21")
    implementation(npm("styled-components", "~5.2.1"))

    // Video Player (шаг 7)
    implementation(npm("react-youtube-lite", "1.0.1"))

    // Share Buttons (шаг 7)
    implementation(npm("react-share", "~4.2.1"))

    // Coroutines (шаг 8)
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3")
}</code></pre><br/>
<p>Если отредактировать файл, IDEA автоматически предложит импортировать изменения Gradle скриптов. Импорт также можно инициировать в любой момент, нажав на кнопку <strong> Reimport All Gradle Projects</strong> в тул-окне Gradle (сбоку справа).</p><br/>
<h4 id="html-stranica">HTML страница</h4><br/>
<p>Так как мы не можем вызывать JavaScript сам по себе, мы должны написать связанную с нашим JS файлом HTML страницу, и именно ее открывать в браузере. В проекте уже есть файл <code>src/main/resources/index.html</code> со следующим содержимым:</p><br/>
<pre><code class="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Hello, Kotlin/JS!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script src="confexplorer.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre><br/>
<p>Благодаря Kotlin/JS Gradle плагину, весь наш код и зависимости будут объединены ("забандлены") в единый JavaScript артефакт, носящий с проектом одно имя. Соответственно мы добавили в HTML файл вызов скрипта <code>confexplorer.js</code> (заметьте, что если бы проект был назван, например, как <code>followingAlong</code>, имя скрипта было бы <code>followingAlong.js</code>).</p><br/>
<p>Выполняя обыденную <a href="https://faqs.skillcrush.com/article/176-where-should-js-script-tags-be-linked-in-html-documents" rel="nofollow noopener noreferrer">конвенцию JavaScript</a>, мы сначала позволяем загрузить контент нашей страницы (включая элемент <code>#root</code>) и только в конце загружаем скрипт. Таким образом, страница будет загружена к моменту выполнения нашего скрипта, и мы сможем сразу же к ней обращаться.</p><br/>
<p><strong>Примечание от переводчика</strong>: если у вас уже есть опыт с HTML, возможно, вы привыкли использовать свойство <code>onLoad</code> у элемента <code>body</code> для решения этой же проблемы. Однако при использовании Kotlin/JS намного проще именно просто объявлять скрипт в конце <code>body</code>.</p><br/>
<p>Перед написанием "Hello, World" с настоящей разметкой, начнем с простейшего визуального примера – страницы, залитой сплошным цветом. Этот пример поможет понять, то что наш код действительно доходит до браузера и выполняется без ошибок. Для кода у нас есть файл <code>src/main/kotlin/Main.kt</code> с таким содержимым:</p><br/>
<pre><code class="kotlin">import kotlinx.browser.document

fun main() {
    document.bgColor = "red"
}</code></pre><br/>
<p>Теперь нам нужно скомпилировать и запустить наш код.</p><br/>
<h3 id="zapusk-servera-dlya-razrabotki">Запуск сервера для разработки</h3><br/>
<p>Kotlin/JS Gradle плагин из коробки поддерживает <strong>webpack-dev-server</strong>, что позволяет нам хостить приложение прямо с помощью IDE и не настраивать веб сервер отдельно.</p><br/>
<p>Мы можем запустить сервер, вызвав задачу <code>run</code> или <code>browserDevelopmentRun</code> из тул-окна Gradle. Она может быть либо в группе <code>other</code> (как на скриншоте), либо в <code>kotlin browser</code>:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/897/290/973/897290973b762d0318e9a62b3971a221.png" alt="Задача для запуска сервера" data-src="https://habrastorage.org/getpro/habr/post_images/897/290/973/897290973b762d0318e9a62b3971a221.png"/></p><br/>
<p>Если хочется запускать не из IDE, а из терминала, то можно выполнить <code>./gradlew run</code> (<em>в Windows</em> Gradle команды выглядят немного по-другому: <code>.\gradlew.bat run</code>).</p><br/>
<p>Наш проект скомпилируется и забандлится, и через несколько секунд должно открыться окно браузера с пустой красной страницей, означающей, что наш код заработал успешно:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/dc2/12f/22f/dc212f22f7b4bd36e6d18600f87ef77a.png" alt="Красная страница" data-src="https://habrastorage.org/getpro/habr/post_images/dc2/12f/22f/dc212f22f7b4bd36e6d18600f87ef77a.png"/></p><br/>
<h4 id="vklyuchenie-goryachey-perezagruzki-hot-reload-aka-nepreryvnogo-rezhima">Включение горячей перезагрузки (hot reload) a.k.a. непрерывного режима</h4><br/>
<p>Вместо того чтобы вручную вызывать компиляцию проекта и обновление страницы в браузере для тестирования изменений в коде, мы можем использовать <em>режим непрерывной компиляции</em> – Kotlin/JS поддерживает ее. Для этого нам потребуется немного модифицировать вызов <code>run</code> задачи Gradle.</p><br/>
<p>Необходимо также убедиться, что запущенный ранее веб сервер остановлен (нажмите в IDE на красный квадрат – <strong>Stop</strong>; если работаете в терминале – нажмите <code>Ctrl+C</code>).</p><br/>
<p>Если вы запускаете задачу с помощью IDEA, нужно добавить флаг в конфигурацию запуска. Эту конфигурацию IDEA создала, когда мы впервые запустили Gradle задачу, а теперь нам нужно ее отредактировать:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/81c/a95/32c/81ca9532c243740abf29334207164d52.png" alt="Открытие редактирования" data-src="https://habrastorage.org/getpro/habr/post_images/81c/a95/32c/81ca9532c243740abf29334207164d52.png"/></p><br/>
<p>В открывшемся окне <strong>Run/Debug Configurations</strong> надо добавить флаг <code>--continuous</code> в аргументы конфигурации запуска:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/275/194/45d/27519445d08e39e965416a2db3c07892.png" alt="Добавление аргумента" data-src="https://habrastorage.org/getpro/habr/post_images/275/194/45d/27519445d08e39e965416a2db3c07892.png"/></p><br/>
<p>После применения изменений мы можем использовать зеленую кнопку <strong>Run</strong> (<code>|&gt;</code>) для запуска сервера.</p><br/>
<p>Если вы запускаете сервер из терминала, это можно сделать примерно так: <code>./gradlew run --continuous</code>.</p><br/>
<p>Для тестирования только что активированной функции предлагаем изменить цвет страницы, когда Gradle задача выполняется. Например, можно изменить на синий:</p><br/>
<pre><code class="kotlin">document.bgColor = "blue"</code></pre><br/>
<p>Если сохранить файл, через пару секунд проект должен автоматически перекомпилироваться, а страница браузера – перезагрузиться и окраситься в новый цвет.</p><br/>
<p>Во время разработки можно оставлять сервер запущенным. Он будет следить за изменениями в коде и автоматически компилировать код и перезагружать страницу. Если хотите, можете поиграться с кодом на этой начальной стадии.</p><br/>
<h4 id="primechanie-ot-perevodchika-naschet-nepreryvnoy-kompilyacii">Примечание от переводчика насчет непрерывной компиляции</h4><br/>
<p>Я пробовал этот режим, и, если честно, он мне показался неудобным. Во-первых, перезагрузка страницы иногда бывает нежелательна, особенно если там были какие-то несохраненные данные. Во-вторых, я не всегда понимаю, успели ли уже перекомпилироваться код и перезагрузиться страница. В-третьих, этот режим почему-то не всегда видит изменения, и доходит до того, что приходится перезапускать Gradle задачу, то есть сама суть режима нарушается – все еще приходится делать что-то руками.</p><br/>
<p>В итоге я уже года два, с момента начала моего использования Kotlin/JS, вручную запускаю компиляцию кода и перезагрузку страницы. Более того, я вообще не использую веб сервер при разработке: я просто открываю в браузере локальный HTML файл. Для компиляции я использую задачу <code>browserDevelopmentWebpack</code>, после этого построенные файлы становятся доступны в папке <code>build/distributions</code> или в <code>build/developmentExecutable</code>. Оттуда я переношу в браузер файл <code>index.html</code>, и все работает довольно безотказно и предельно логично.</p><br/>
<h3 id="na-start-vnimanie">На старт, внимание...</h3><br/>
<p>Мы настроили пустой Kotlin/JS проект, который может развиться во все что угодно. Время начинать верстать!</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>master</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/master" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep3shag-3-pervaya-stranica-na-reakte--statichnayaa">Шаг 3. Первая страница на Реакте – статичная</h2><br/>
<p>В мире программирования принято начинать обучение с <em>Hello, World</em>. Так давайте изменим нашу одноцветную страницу в соответствии с традициями.</p><br/>
<p>Поменяйте код в файле <code>src/main/kotlin/Main.kt</code> на примерно следующий:</p><br/>
<pre><code class="kotlin">import react.dom.*
import kotlinx.browser.document

fun main() {
    render(document.getElementById("root")) {
        h1 {
            +"Hello, React+Kotlin/JS!"
        }
    }
}</code></pre><br/>
<p>После сборки изменившегося проекта в браузере можно увидеть магию:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/ada/0a2/550/ada0a25506506187b003da6597154be9.png" alt="hello-world" data-src="https://habrastorage.org/getpro/habr/post_images/ada/0a2/550/ada0a25506506187b003da6597154be9.png"/></p><br/>
<p>Ура, вы только что написали свой первый веб сайт на чистом Котлине с Реактом! Давайте попробуем понять, как работает этот код. Функция <code>render</code> говорит библиотеке <a href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-dom" rel="nofollow noopener noreferrer">kotlin-react-dom</a> отрендерить наш <em>компонент</em> (поговорим о компонентах чуть позже) внутрь элемента на странице. Если помните, в <code>src/main/resources/index.html</code> есть элемент с ID <code>root</code>, как раз туда мы и рендерим. Содержимое рендеринга сейчас довольно простое – единственный заголовок первого уровня. Для объявления содержимого, то есть HTML элементов, используется типобезопасный DSL.</p><br/>
<h3 id="tipobezopasnyy-html">Типобезопасный HTML</h3><br/>
<p>Библиотека <a href="https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-react/README.md" rel="nofollow noopener noreferrer">kotlin-react</a> использует котлиновскую возможность написания DSL, таким образом заменяя синтаксис разметки HTML на нечто более легкочитаемое. Возможно, такой DSL вам покажется и легче в написании.</p><br/>
<p>Код на Котлине дает нам все преимущества статически типизированного языка, от <em>проверки типов</em> до <em>автодополнения</em>. Скорее всего, из-за этого вы проведете <em>меньше времени в отладке</em>, охотясь за опечатками в именах атрибутов, и у вас появится <em>больше времени на создание</em> отточенного приложения!</p><br/>
<p><strong>О знаке <code>+</code></strong>:</p><br/>
<p>Единственная довольно неочевидная на первый взгляд вещь в котлиновском листинге выше – знак <code>+</code> перед строковым литералом. Поясним. <code>h1</code> – это функция, принимающая лямбду как параметр. Когда мы пишем <code>+</code>, мы на самом деле вызываем <a href="https://kotlinlang.org/docs/reference/operator-overloading.html" rel="nofollow noopener noreferrer">перегруженный оператор</a> <code>unaryPlus</code>, которая добавляет строку в окружающий HTML элемент.</p><br/>
<p>Проще говоря, операцию <code>+</code> можно понимать как инструкцию "добавь мою строчку текста внутрь этого элемента".</p><br/>
<h4 id="perepisyvaem-klassicheskiy-html">Переписываем классический HTML</h4><br/>
<p>Когда у нас есть мысли о том, как будет выглядеть наш сайт, мы можем сразу перевести наш (мысленный) набросок в котлиновское объявление HTML. Если вы уже привыкли писать обычный HTML, у вас не должно возникнуть проблем и с котлиновским. Сейчас мы хотим создать разметку, которую можно записать примерно так на чистом HTML:</p><br/>
<pre><code class="html">&lt;h1&gt;KotlinConf Explorer&lt;/h1&gt;
&lt;div&gt;
    &lt;h3&gt;Videos to watch&lt;/h3&gt;
    &lt;p&gt;John Doe: Building and breaking things&lt;/p&gt;
    &lt;p&gt;Jane Smith: The development process&lt;/p&gt;
    &lt;p&gt;Matt Miller: The Web 7.0&lt;/p&gt;

    &lt;h3&gt;Videos watched&lt;/h3&gt;
    &lt;p&gt;Tom Jerry: Mouseless development&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;h3&gt;John Doe: Building and breaking things&lt;/h3&gt;
    &lt;img src="https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"&gt;
&lt;/div&gt;</code></pre><br/>
<p>Давайте переведем этот код в Kotlin DSL. Конверсия довольно прямолинейна. Если хотите поупражняться, можете попробовать переписать самостоятельно, <strong>не подглядывая</strong> в листинг ниже:</p><br/>
<pre><code class="kotlin">h1 {
    +"KotlinConf Explorer"
}
div {
    h3 {
        +"Videos to watch"
    }
    p {
        +"John Doe: Building and breaking things"
    }
    p {
        +"Jane Smith: The development process"
    }
    p {
        +"Matt Miller: The Web 7.0"
    }

    h3 {
        +"Videos watched"
    }
    p {
        +"Tom Jerry: Mouseless development"
    }
}
div {
    h3 {
        +"John Doe: Building and breaking things"
    }
    img {
       attrs {
           src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
       }
    }
}</code></pre><br/>
<p>Перепишите или скопируйте этот листинг внутрь вызова <code>render</code>. Если IntelliJ IDEA ругается на отсутствующие импорты, просто вызовите соответствующие быстрые исправления (quick-fixes) с помощью <code>Alt+Enter</code>. Когда обновленный файл будет скомпилирован и страница в браузере перезагружена, вас будет приветствовать следующий экран:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/aff/20b/47c/aff20b47c153c8002fea293f13976a4b.png" alt="kotlinconf-placeholder" data-src="https://habrastorage.org/getpro/habr/post_images/aff/20b/47c/aff20b47c153c8002fea293f13976a4b.png"/></p><br/>
<h3 id="ispolzovanie-kotlinovskih-yazykovyh-konstrukciy-v-razmetke">Использование котлиновских языковых конструкций в разметке</h3><br/>
<p>Написание HTML на DSL на самом деле имеет намного больше преимуществ по сравнению с чистым HTML. Основное отличие – это то что мы можем жонглировать контентом страницы, используя <strong>уже знакомые нам конструкции языка</strong>. Условные переходы, циклы, коллекции, подстановка внутри строк – все это будет работать в HTML DSL так же, как и обычно в Котлине.</p><br/>
<p>Давайте теперь вместо захардкоживания списка видео объявим переменную-список и будем ее использовать в разметке. Создадим класс <code>KotlinVideo</code>, чтобы хранить свойства видео (класс можно создать либо в <code>Main.kt</code>, либо в другом файле – как хотите), а также <code>external</code> интерфейс – о нем поговорим позже, когда будем получать данные из внешнего API:</p><br/>
<pre><code class="kotlin">external interface Video {
    val id: Int
    val title: String
    val speaker: String
    val videoUrl: String
}

data class KotlinVideo(
    override val id: Int,
    override val title: String,
    override val speaker: String,
    override val videoUrl: String
) : Video</code></pre><br/>
<p>Потом объявим два списка: для непросмотренных и просмотренных видео. Пока что можно сделать это в файле <code>Main.kt</code> на верхнем уровне:</p><br/>
<pre><code class="kotlin">val unwatchedVideos = listOf(
    KotlinVideo(1, "Building and breaking things", "John Doe", "https://youtu.be/PsaFVLr8t4E"),
    KotlinVideo(2, "The development process", "Jane Smith", "https://youtu.be/PsaFVLr8t4E"),
    KotlinVideo(3, "The Web 7.0", "Matt Miller", "https://youtu.be/PsaFVLr8t4E")
)

val watchedVideos = listOf(
    KotlinVideo(4, "Mouseless development", "Tom Jerry", "https://youtu.be/PsaFVLr8t4E")
)</code></pre><br/>
<p>Чтобы использовать эти значения в HTML, нам не нужно знать ничего, кроме базового синтаксиса Котлина! Мы можем написать код для прохода по коллекции и добавлять HTML элемент для каждого элемента коллекции. То есть вместо трех тегов <code>p</code> для непросмотренных видео, мы можем написать примерно такое:</p><br/>
<pre><code class="kotlin">for (video in unwatchedVideos) {
    p {
        +"${video.speaker}: ${video.title}"
    }
}</code></pre><br/>
<p>Аналогично можно изменить разметку чуть ниже для использования списка <code>watchedVideos</code>. После перекомпиляции проекта и обновления страницы мы убедимся, что страница эквивалентна предыдущему варианту. Если хотите удостовериться, что циклы на самом деле работают, попробуйте поэкспериментировать и, например, добавить новые элементы в списки.</p><br/>
<h3 id="tipobezopasnyy-css">Типобезопасный CSS</h3><br/>
<p>Можно сказать, мы уже продвинулись в проекте, но не время делать паузу: к сожалению, наше приложение до сих пор выглядит <em>несколько безвкусно</em> и <em>не сильно привлекательно</em>. Для исправления ситуации мы могли бы подключить какой-нибудь <code>.css</code> файл в наш файл <code>index.html</code>, но давайте лучше воспользуемся случаем, чтобы поиграться с Kotlin DSL опять – на этот раз с CSS.</p><br/>
<p>Библиотека <a href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-styled" rel="nofollow noopener noreferrer">kotlin-styled</a> предоставляет чудесные типобезопасные обертки для <a href="https://www.styled-components.com/" rel="nofollow noopener noreferrer">styled-components</a> и позволяет нам быстро и безопасно объявлять стили как <a href="https://github.com/JetBrains/kotlin-wrappers/blob/master/kotlin-styled/README.md#global-styles" rel="nofollow noopener noreferrer">глобально</a>, так индивидуально для конкретных компонентов. Эти обертки очень похожи на концепт <a href="https://reactjs.org/docs/faq-styling.html#what-is-css-in-js" rel="nofollow noopener noreferrer">CSS-in-JS</a>. Описывая стили <em>на Котлине</em>, мы опять же получаем возможность использовать краткие, понятные и единообразные языковые конструкции.</p><br/>
<p>Нам не нужно делать дополнительных шагов для использования этого CSS DSL, так как мы уже добавили все зависимости в конфигурацию Gradle. Вот соответствующий блок:</p><br/>
<pre><code class="kotlin">dependencies {
    //...
    // Kotlin Styled (шаг 3)
    implementation("org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21")
    implementation(npm("styled-components", "~5.2.1"))
    //...
}</code></pre><br/>
<p>Теперь вместо блоков вроде <code>div</code> или <code>h3</code> мы можем использовать их аналоги с префиксом <code>styled</code>, например, <code>styledDiv</code> или <code>styledH3</code>. Внутри их тел стили можно настраивать с помощью блока <code>css</code>. Например, для сдвига видеоплеера в правый верхний угол страницы, мы можем изменить наш код примерно так:</p><br/>
<pre><code class="kotlin">styledDiv {
    css {
        position = Position.absolute
        top = 10.px
        right = 10.px
    }
    h3 {
        +"John Doe: Building and breaking things"
    }
    img {
        attrs {
            src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
        }
    }
}</code></pre><br/>
<p>Скорее всего, IDEA начнет жаловаться на непонятные ссылки. Мы можем избавиться от этих ошибок, добавив импорты сверху в файле:</p><br/>
<pre><code class="kotlin">import kotlinx.css.*
import styled.*</code></pre><br/>
<p>Или можно воспользоваться быстрыми исправлениями с помощью <code>Alt+Enter</code> для добавления импортов автоматически.</p><br/>
<p>Мы привели довольно минималистичный пример. Не стесняйтесь поэкспериментировать – изменять стиль приложения, как душе угодно. Можете даже поиграться с CSS Grids, чтобы сделать интерфейс отзывчивым (но эта тема уже слишком сложна для этого туториала). Попробуйте сделать шрифт (свойство <code>fontFamily</code>) заголовка без засечек (значение <code>sans-serif</code>), или, например, сделать гармоничные цвета (свойство <code>color</code>).</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>step-02-first-static-page</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-02-first-static-page" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep4shag-4-react--o-reakciyah-nash-pervyy-komponenta">Шаг 4. React – о реакциях. Наш первый компонент</h2><br/>
<h3 id="osnovnaya-ideya">Основная идея</h3><br/>
<p>Базовые строительные блоки в Реакте называются <strong>компонентами</strong>. Комбинируя компоненты, часть из которых в свою может быть комбинацией других более маленьких, мы создаем приложение. Делая компоненты переиспользуемыми и обобщенными, мы можем помещать их в несколько мест в приложении, <em>не дублируя</em> код и/или логику.</p><br/>
<p>На самом деле, <em>корневой элемент</em> нашего рендеринга тоже можно представить как компонент. Если мы отметим его рамкой, то это будет выглядеть примерно так:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/f70/411/691/f70411691aa04c00591ceefbeda5b3d9.png" alt="root-component" data-src="https://habrastorage.org/getpro/habr/post_images/f70/411/691/f70411691aa04c00591ceefbeda5b3d9.png"/></p><br/>
<p>А если посмотреть на структуру приложения, то можно найти следующие компоненты, каждый из которых имеет свою ответственность:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/a5f/b36/ef7/a5fb36ef7172f53642a2e5364fb19319.png" alt="split-components" data-src="https://habrastorage.org/getpro/habr/post_images/a5f/b36/ef7/a5fb36ef7172f53642a2e5364fb19319.png"/></p><br/>
<h3 id="kornevoy-komponent">Корневой компонент</h3><br/>
<p>Давайте разобьем приложение на компоненты в соответствии с его структурой. Начнем с явного объявления главного компонента <code>App</code>, который будет являться корневым. Для этого создадим файл <code>App.kt</code> по пути <code>src/main/kotlin</code> в проекте. Внутри файла опишем класс <code>App</code>, наследующий <code>RComponent</code> (сокращение от <strong>R</strong>eact <strong>Component</strong>). Дженерики пока что можно оставить стандартными (<code>RProps</code> и <code>RState</code>), а потом разберемся и с ними:</p><br/>
<pre><code class="kotlin">import react.*

@JsExport
class App : RComponent&lt;RProps, RState&gt;() {

    override fun RBuilder.render() {
        // Помещаем сюда типобезопасный HTML!
    }
}</code></pre><br/>
<p>Переместите весь наш типобезопасный HTML внутрь новой функции <code>render</code>. Таким образом мы поместили весь код приложения в соответствующе названный явный компонент. Теперь функция <code>main</code> должна как-то ссылаться на <code>App</code>. Это делается очень просто: достаточно сказать Реакту рендерить компонент <code>App</code> как ребенка корневого элемента, используя функцию <code>child</code>:</p><br/>
<pre><code class="kotlin">fun main() {
    render(document.getElementById("root")) {
        child(App::class) {}
    }
}</code></pre><br/>
<p>В ходе практики мы будем создавать и использовать компоненты, так что скорее всего вы станете понимать их лучше. Но если есть желание нырнуть в Реакт поглубже, рекомендуем изучить <a href="https://reactjs.org/docs/hello-world.html#how-to-read-this-guide" rel="nofollow noopener noreferrer">официальную документацию и гайды</a>.</p><br/>
<h3 id="komponent-dlya-spiska">Компонент для списка</h3><br/>
<p>Какие части нашего приложения дублируются? Конечно же, <em>списки видео</em> – и это сразу же заметно. Так как и список непросмотренного, и список просмотренного имеют одинаковую функциональность, есть смысл создать единый компонент и переиспользовать его.</p><br/>
<p>Сделаем это в новом файле <code>VideoList.kt</code>. Подобно классу <code>App</code>, создадим класс <code>VideoList</code>, наследующий <code>RComponent</code> и содержащий HTML DSL со списком <code>unwatchedVideos</code>:</p><br/>
<pre><code class="kotlin">import react.*
import react.dom.*

@JsExport
class VideoList : RComponent&lt;RProps, RState&gt;() {

    override fun RBuilder.render() {
        for (video in unwatchedVideos) {
            p {
                +"${video.speaker}: ${video.title}"
            }
        }
    }
}</code></pre><br/>
<p>Теперь часть со списками внутри <code>App</code> можно сделать примерно такой:</p><br/>
<pre><code class="kotlin">div {
    h3 {
        +"Videos to watch"
    }
    child(VideoList::class) {}

    h3 {
        +"Videos watched"
    }
    child(VideoList::class) {}
}</code></pre><br/>
<p>Однако здесь можно заметить проблему: <code>App</code> не управляет содержимым списка. Сейчас содержимое захардкожено и будет всегда одинаковое. Выходит, нам нужен механизм передачи списка <em>внутрь компонента</em>.</p><br/>
<h3 id="dobavlyaem-atributy">Добавляем атрибуты</h3><br/>
<p>Теперь мы понимаем, что при переиспользовании компонента-списка мы бы хотели заполнять его разным содержимым. Другими словами, вместо хранения списка элементов статически, мы хотели бы задавать его внешне и передавать компоненту как атрибуты. В терминологии Реакта такие атрибуты называются <code>props</code>. Когда атрибуты задаются, Реакт берет на себя задачу по их передаче в компонент и по рендерингу компонента.</p><br/>
<p>В нашем случае мы хотим добавить атрибут, содержащий список докладов. Давайте переработаем наш код. Создайте следующий интерфейс в файле <code>VideoList.kt</code>:</p><br/>
<pre><code class="kotlin">external interface VideoListProps : RProps {
    var videos: List&lt;Video&gt;
}</code></pre><br/>
<p>Теперь изменим объявление класса <code>VideoList</code>, чтобы он использовал этот атрибут:</p><br/>
<pre><code class="kotlin">@JsExport
class VideoList : RComponent&lt;VideoListProps, RState&gt;() {

    override fun RBuilder.render() {
        for (video in props.videos) {
            p {
                key = video.id.toString()
                +"${video.speaker}: ${video.title}"
            }
        }
    }
}</code></pre><br/>
<p>Так как содержимое компонента теперь потенциально динамично (то есть переданные в рантайме атрибуты могут меняться, мы так и будем делать в следующих шагах), следует проставлять свойство <code>key</code> в каждый элемент списка. Он помогает Реакту понять, какие части списка нужно обновить, а какие можно оставить без изменений – хорошая и почти бесплатная оптимизация! Больше информации насчет списков и ключей можно найти, например, в <a href="https://reactjs.org/docs/lists-and-keys.html" rel="nofollow noopener noreferrer">официальном гайде Реакта</a>.</p><br/>
<p>Наконец, на месте использования <code>VideoList</code> (внутри <code>App</code>) нам остается передать правильные атрибуты. Подставьте <code>unwatchedVideos</code> и <code>watchedVideos</code> примерно так:</p><br/>
<pre><code class="kotlin">child(VideoList::class) {
    attrs.videos = unwatchedVideos
}</code></pre><br/>
<p>Проверьте в браузере, что списки рендерятся, как задумано. Таким образом, мы инкапсулировали обязанность рендеринга списка видео внутри соответствующего компонента. Это должно укорачивать исходный код и делать его более легкочитаемым и понимаемым как для нас, так и для коллег.</p><br/>
<h3 id="umenshaem-gromozdkost-vyzova">Уменьшаем громоздкость вызова</h3><br/>
<p>Если вам тоже не очень нравится предыдущая конструкция, мы можем улучшить ее, используя крутую котлиновскую фичу под названием <a href="https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver" rel="nofollow noopener noreferrer">функция с получателем</a>. Выделим функцию, которая делает доступ к компонентам легче: она выполняет то же самое, что и предыдущая конструкция, но изменяет синтаксис использования:</p><br/>
<pre><code class="kotlin">fun RBuilder.videoList(handler: VideoListProps.() -&gt; Unit): ReactElement {
    return child(VideoList::class) {
        attrs.handler()
    }
}</code></pre><br/>
<p>Расскажем, что происходит в этом коде: мы определяем функцию <code>videoList</code> как <a href="https://kotlinlang.org/docs/reference/extensions.html" rel="nofollow noopener noreferrer">расширение</a> для типа <code>RBuilder</code>. Функция принимает единственный параметр <code>handler</code> – функцию-расширение для <code>VideoListProps</code>, возвращающую <code>Unit</code>. Функция оборачивает вызов <code>child</code> (который мы делали изначально для вставки <code>VideoList</code>), и вызывает <code>handler</code> на объекте <code>attrs</code>.</p><br/>
<p>Основной смысл такой функции – облегчение синтаксиса использования нашего компонента: теперь мы можем писать просто</p><br/>
<pre><code class="kotlin">videoList {
    videos = unwatchedVideos
}</code></pre><br/>
<p>В общем, мы убираем из вызова не сильно информативные слова типа <code>child</code>, <code>class</code> и <code>attrs</code>, оставляя только специфичные для конкретного компонента символы. Аналогичные функции можно писать для всех компонентов, которые вы описываете. Запомните этот трюк! При желании потренироваться уже сейчас можете попробовать это проделать для класса <code>App</code>.</p><br/>
<h3 id="dobavlyaem-interaktivnost">Добавляем интерактивность</h3><br/>
<p>Основная цель нашего компонента-списка – задавать видео для показа в видеоплеере. Чтобы это сделать, нужно позволить пользователю взаимодействовать с элементами списка. Начнем с простого: будем показывать выбранное пользователем видео в диалоге <code>alert</code>.</p><br/>
<p>Для этого модифицируем код внутри функции <code>VideoList.render</code>. Сделаем так, чтобы при клике на элемент <code>p</code> соответствующее сообщение показывалось бы в диалоге:</p><br/>
<pre><code class="kotlin">p {
    key = video.id.toString()
    attrs {
        onClickFunction = {
            window.alert("Clicked $video!")
        }
    }
    +"${video.speaker}: ${video.title}"
}</code></pre><br/>
<p>Если IntelliJ IDEA просит добавить импорты, это можно сделать по нажатию <code>Alt+Enter</code>. Или можно добавить импорты вручную:</p><br/>
<pre><code class="kotlin">import kotlinx.html.js.onClickFunction
import kotlinx.browser.window</code></pre><br/>
<p>Теперь при клике на элементе списка в браузере мы увидим всплывающее сообщение о выбранном элементе:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/07f/85e/867/07f85e8677b33e952fdc2734aee60e95.png" alt="alert" data-src="https://habrastorage.org/getpro/habr/post_images/07f/85e/867/07f85e8677b33e952fdc2734aee60e95.png"/></p><br/>
<blockquote>Оформлять значение <code>onClickFunction</code> как лямбду довольно коротко, и это удобно как минимум для прототипирования. Однако на данный момент эквивалентность ссылок на функции в Kotlin/JS работает <a href="https://youtrack.jetbrains.com/issue/KT-15101" rel="nofollow noopener noreferrer">не очень очевидно</a>. Поэтому передача лямбды на самом деле не сильно эффективна в плане производительности. Если вам нужна максимальная эффективность, необходимо сохранять ссылки на функции в неменяющихся во время выполнения переменных и передавать в качестве значений для <code>onClickFunction</code> и других подобных свойств эти переменные.</blockquote><br/>
<h3 id="dobavlyaem-sostoyanie">Добавляем состояние</h3><br/>
<p>Не устали?</p><br/>
<p>Давайте сделаем настоящий селектор видео вместо вывода всплывающего сообщения. Будем подсвечивать выбранное видео треугольником (<code>|&gt;</code>). Реакт нам поможет – он позволяет ввести некоторое <em>состояние</em> для компонента. Это будет очень похоже на добавление атрибутов – надо объявить интерфейс:</p><br/>
<pre><code class="kotlin">external interface VideoListState : RState {
    var selectedVideo: Video?
}</code></pre><br/>
<p>Дальше надо сделать следующее:</p><br/>
<ul>
<li>Подредактировать объявление класса <code>VideoList</code>, чтобы в качестве типа состояния он использовал <code>VideoListState</code> – нужно унаследовать компонент от <code>RComponent&lt;..., VideoListState&gt;</code>.</li>
<li>При рендеринге списка для выбранного видео мы должны выводить треугольник в качестве префикса.</li>
<li>Внутри <code>onClickFunction</code> надо записывать в состояние <code>selectedVideo</code> то видео, которое соответствует кликнутому элементу. Чтобы компонент перерисовывался при изменении состояния, код для изменения нужно обернуть лямбду и передать ее в функцию <code>setState</code>. </li>
</ul><br/>
<p>Когда проделаем это, мы получим такой класс:</p><br/>
<pre><code class="kotlin">@JsExport
class VideoList : RComponent&lt;VideoListProps, VideoListState&gt;() {

    override fun RBuilder.render() {
        for (video in props.videos) {
            p {
                key = video.id.toString()
                attrs {
                    onClickFunction = {
                        setState {
                            selectedVideo = video
                        }
                    }
                }
                if (video == state.selectedVideo) {
                    +"|&gt; "
                }
                +"${video.speaker}: ${video.title}"
            }
        }
    }
}</code></pre><br/>
<blockquote><strong>Состояние стоит модифицировать только внутри <code>setState</code></strong>. Так Реакт сможет обнаружить изменения и перерисовать нужные части UI быстро и эффективно.</blockquote><p>На этом шаге у нас все, но более подробно о состоянии можно почитать в официальном <a href="https://reactjs.org/docs/faq-state.html" rel="nofollow noopener noreferrer">React FAQ</a>.</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>step-03-first-component</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-03-first-component" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep5shag-5-rabotaem-sovmestno-kompoziciya-komponentova">Шаг 5. Работаем совместно. Композиция компонентов</h2><br/>
<p>Сделанные нами на предыдущем шаге пара списков сами по себе вполне работают. Однако, если мы кликнем по одному видео в каждом из списков, мы можем выбрать <em>два видео</em> одновременно. Это неправильно, ведь у нас только один плеер :)<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/188/255/3e3/1882553e39a1d6e05dc7f3b637e2bb9d.png" alt="pair" data-src="https://habrastorage.org/getpro/habr/post_images/188/255/3e3/1882553e39a1d6e05dc7f3b637e2bb9d.png"/></p><br/>
<p>По-хорошему, у обоих списков должно быть единое состояние – выбранное видео, которое будет одним на все приложение. Но единое состояние не может (и не должно) храниться в разных компонентах. Принято выносить состояние наверх (как еще говорят, "поднимать" состояние).</p><br/>
<h3 id="vynos-sostoyaniya-naverh">Вынос состояния наверх</h3><br/>
<p>Чтобы не прибивать гвоздями разные компоненты друг к другу и не создавать спагетти-код, можно воспользоваться иерархией компонентов Реакта: передавать атрибуты из родительского компонента. Если компонент хочет изменять состояние соседнего компонента, это следует делать через общего родителя. Значит, состояние должно быть не в соседнем компоненте, а именно в родителе. Миграция состояния из компонента к родителю называется <strong>выносом</strong> состояния. Давайте выносить его в нашем случае! Для этого нам нужно добавить состояние для нашего родительского компонента, <code>App</code>. Будем действовать примерно так же, как и с состоянием для <code>VideoList</code>.</p><br/>
<p>Объявим интерфейс:</p><br/>
<pre><code class="kotlin">external interface AppState : RState {
    var currentVideo: Video?
}</code></pre><br/>
<p>И сошлемся на него в классе <code>App</code>:</p><br/>
<pre><code class="kotlin">@JsExport
class App : RComponent&lt;RProps, AppState&gt;()</code></pre><br/>
<p>Удалим <code>VideoListState</code>, так как мы теперь будем хранить эту информацию выше. Получается, мы вообще убрали состояние у списка, так что вернем его состояние к стандартному в описании класса:</p><br/>
<pre><code class="kotlin">@JsExport
class VideoList : RComponent&lt;VideoListProps, RState&gt;()</code></pre><br/>
<p>Теперь передадим вниз состояние выбранного видео из <code>App</code> в <code>VideoList</code> как атрибут. Добавим свойство в интерфейс <code>VideoListProps</code>, которое будет содержать выбранное видео:</p><br/>
<pre><code class="kotlin">external interface VideoListProps : RProps {
    var videos: List&lt;Video&gt;
    var selectedVideo: Video?
}</code></pre><br/>
<p>Поправим условие для показа треугольника выбранного видео, чтобы оно использовало атрибуты вместо состояния:</p><br/>
<pre><code class="kotlin">if (video == props.selectedVideo) {
    +"|&gt; "
}</code></pre><br/>
<p>Но есть еще одна проблема, которую создал наш рефакторинг: у компонента нет доступа к родительскому состоянию, так что вызов <code>setState</code> внутри <code>onClickFunction</code> не сможет сделать ничего полезного. Чтобы побороть это и в итоге опять получить работающее приложение, давайте поднимем кое-что еще.</p><br/>
<h3 id="peredacha-obrabotchikov">Передача обработчиков</h3><br/>
<p>К сожалению, Реакт не позволяет изменять состояние родительского компонента напрямую, как бы мы этого ни хотели. Но мы можем поступить по-другому: перенести логику обработки действия пользователя в атрибут и передавать его из родителя. Помните, что в Котлине у переменных может быть <a href="https://kotlinlang.org/docs/reference/lambdas.html#function-types" rel="nofollow noopener noreferrer">функциональный тип</a>? Добавим еще в одно свойство в интерфейс – функцию, принимающую <code>Video</code> и возвращающую <code>Unit</code>:</p><br/>
<pre><code class="kotlin">external interface VideoListProps : RProps {
    var videos: List&lt;Video&gt;
    var selectedVideo: Video?
    var onSelectVideo: (Video) -&gt; Unit
}</code></pre><br/>
<p>И соответственно поменяем <code>onClickFunction</code> на вызов этой функции из атрибутов:</p><br/>
<pre><code class="kotlin">onClickFunction = {
    props.onSelectVideo(video)
}</code></pre><br/>
<p>Теперь мы сможем передавать выбранное видео как атрибут и вынести логику <em>выбора</em> видео в родительский компонент, где и будем менять состояние. Иными словами, мы хотим поднять логику обработки кликов в родителя. Обновим оба места использования <code>videoList</code>:</p><br/>
<pre><code class="kotlin">videoList {
    videos = unwatchedVideos
    selectedVideo = state.currentVideo
    onSelectVideo = { video -&gt;
        setState {
            currentVideo = video
        }
    }
}</code></pre><br/>
<p>Второе место отличается присваиванием <code>watchedVideos</code>.</p><br/>
<p>При необходимости перекомпилируйте проект и убедитесь, что теперь все работает логично: при выборе видео в двух списках, треугольник перепрыгивает между списками, а не дублируется. Возможно, вы даже удивитесь, как все оказалось просто.</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>step-04-composing-components</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-04-composing-components" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep6shag-6-bolshe-komponentova">Шаг 6. Больше компонентов!</h2><br/>
<p>Мы сделали один компонент отдельным и самодостаточным, а также оставили у него возможность взаимодействовать с приложением. Давайте проделаем то же самое для остальных частей приложения.</p><br/>
<h3 id="vynosim-komponent-videopleera">Выносим компонент видеоплеера</h3><br/>
<p>Еще одна часть приложения, которую стоит вынести как обособленную единицу – это видеоплеер (его мы все еще заменяем картинкой-заглушкой). Давайте подумаем, какие атрибуты понадобятся для видеоплеера: это автор видео, название и ссылка. На самом деле, все эти свойства уже имеет объект типа <code>Video</code>, так что будем передавать его как атрибут. Создадим новый компонент <code>VideoPlayer</code> в файле <code>VideoPlayer.kt</code>:</p><br/>
<pre><code class="kotlin">import kotlinx.css.*
import kotlinx.html.js.onClickFunction
import react.*
import react.dom.*
import styled.*

external interface VideoPlayerProps : RProps {
    var video: Video
}

@JsExport
class VideoPlayer : RComponent&lt;VideoPlayerProps, RState&gt;() {
    override fun RBuilder.render() {
        styledDiv {
            css {
                position = Position.absolute
                top = 10.px
                right = 10.px
            }
            h3 {
                +"${props.video.speaker}: ${props.video.title}"
            }
            img {
                attrs {
                    src = "https://via.placeholder.com/640x360.png?text=Video+Player+Placeholder"
                }
            }
        }
    }
}

fun RBuilder.videoPlayer(handler: VideoPlayerProps.() -&gt; Unit): ReactElement {
    return child(VideoPlayer::class) {
        this.attrs(handler)
    }
}</code></pre><br/>
<p>Теперь заменим предыдущий <code>styledDiv</code> с видеоплеером (в файле <code>App.kt</code>) на только что вынесенный компонент. Будем его отрисовывать, только если выбрано какое-то видео – воспользуемся комбинацией оператора безопасного вызова и функции <code>let</code>, тогда переданный в <code>let</code> блок кода будет выполняться, если <code>currentVideo</code> не равно <code>null</code>:</p><br/>
<pre><code class="kotlin">state.currentVideo?.let { currentVideo -&gt;
    videoPlayer {
        video = currentVideo
    }
}</code></pre><br/>
<h3 id="dobavlyaem-i-prisoedinyaem-knopku">Добавляем и присоединяем кнопку</h3><br/>
<p>Пока что в приложении нет способа двигать видео между списками непросмотренных и просмотренных. Для решения этой задачи добавим кнопку в <code>VideoPlayer</code>.</p><br/>
<p>Мы хотим двигать элементы между разными списками, а они находятся за пределами нашего компонента <code>VideoPlayer</code>. Вспомним, что в подобных случаях нам надо выносить в общего родителя логику обработки нажатия кнопки.</p><br/>
<p>Попробуем сделать кнопку-переключатель. При нажатии ее состояние, например, текст, будет изменяться в зависимости от того, просмотрено видео или нет. Для этого будем передавать еще и состояние кнопки.</p><br/>
<p>Добавим еще свойств в интерфейс <code>VideoPlayerProps</code>:</p><br/>
<pre><code class="kotlin">external interface VideoPlayerProps : RProps {
    var video: Video
    var onWatchedButtonPressed: (Video) -&gt; Unit
    var unwatchedVideo: Boolean
}</code></pre><br/>
<p>Мы уже создали несколько компонентов, так что реализация кнопки не должна быть сложной задачей. Попробуем использовать атрибуты для изменения CSS свойств: будем раскрашивать кнопку динамически на основе состояния видео. Добавим следующий HTML DSL в метод <code>render</code> видеоплеера, между тегами <code>h3</code> и <code>img</code>:</p><br/>
<pre><code class="kotlin">styledButton {
    css {
        display = Display.block
        backgroundColor = if (props.unwatchedVideo) Color.lightGreen else Color.red
    }
    attrs {
        onClickFunction = {
            props.onWatchedButtonPressed(props.video)
        }
    }
    if (props.unwatchedVideo) {
        +"Mark as watched"
    } else {
        +"Mark as unwatched"
    }
}</code></pre><br/>
<h3 id="peremeschaem-spiski-video-v-sostoyanie-prilozheniya">Перемещаем списки видео в состояние приложения</h3><br/>
<p>Перед тем как изменить вызов <code>VideoPlayer</code>, подумаем о логике его работы.</p><br/>
<p>При клике на кнопку видео должно быть либо перенесено из списка <code>unwatched</code> в <code>watched</code>, либо наоборот.</p><br/>
<p>То есть списки могут изменяться. Давайте тогда перенесем их в состояние приложения! Опять добавим дополнительные свойства в интерфейс:</p><br/>
<pre><code class="kotlin">external interface AppState : RState {
    var currentVideo: Video?
    var unwatchedVideos: List&lt;Video&gt;
    var watchedVideos: List&lt;Video&gt;
}</code></pre><br/>
<p>Начальные значения состояния можно задать в методе <code>init</code>. Сделаем это, переопределив метод в классе <code>App</code>:</p><br/>
<pre><code class="kotlin">override fun AppState.init() {
    unwatchedVideos = listOf(
        KotlinVideo(1, "Building and breaking things", "John Doe", "https://youtu.be/PsaFVLr8t4E"),
        KotlinVideo(2, "The development process", "Jane Smith", "https://youtu.be/PsaFVLr8t4E"),
        KotlinVideo(3, "The Web 7.0", "Matt Miller", "https://youtu.be/PsaFVLr8t4E")
    )
    watchedVideos = listOf(
        KotlinVideo(4, "Mouseless development", "Tom Jerry", "https://youtu.be/PsaFVLr8t4E")
    )
}</code></pre><br/>
<p>Теперь можно удалить <code>unwatchedVideos</code> и <code>watchedVideos</code> из файла <code>Main.kt</code>, а в файле <code>Main.kt</code> заменить все вызовы (<code>un</code>)<code>watchedVideos</code>, которые наверняка IDE уже успела подсветить как ошибочные, на <code>state.</code>(<code>un</code>)<code>watchedVideos</code>.</p><br/>
<p>Наконец, подкорректируем вызов видеоплеера. Он будет выглядеть вот так:</p><br/>
<pre><code class="kotlin">videoPlayer {
    video = currentVideo
    unwatchedVideo = currentVideo in state.unwatchedVideos
    onWatchedButtonPressed = {
        if (video in state.unwatchedVideos) {
            setState {
                unwatchedVideos -= video
                watchedVideos += video
            }
        } else {
            setState {
                watchedVideos -= video
                unwatchedVideos += video
            }
        }
    }
}</code></pre><br/>
<p>Вернитесь в браузер, выберите видео, нажмите на кнопку пару раз и убедитесь, что видео перемещается между двумя списками.</p><br/>
<p>Таким образом, мы реализовали основную логику нашего приложения. Будет здорово, если вы поиграетесь со стилями кнопки, и выберете тот, который вам больше всего по душе. Можете даже попробовать вынести кнопку в отдельный переиспользуемый компонент!</p><br/>
<p>Время откинуться на спинку кресла и переложить тяжелую работу на других. В следующем шаге поговорим об использовании готовых и общедоступных Реакт компонентов из Котлина.</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>step-05-more-components</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-05-more-components" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep7shag-7-ispolzovanie-npm-paketova">Шаг 7. Использование NPM пакетов</h2><br/>
<p>Хотя мы уже неплохо продвинулись, в приложении все еще отсутствуют жизненно важные части. Вместо написания всего с нуля, попробуем использовать богатую экосистему, построенную вокруг Реакта. В ней есть тонна уже готовых компонентов, так что давайте действительно не переизобретать велосипед, а использовать их.</p><br/>
<p>Первая и самая очевидная недостающая функциональность – это видеоплеер.</p><br/>
<h3 id="dobavlyaem-komponent-videopleera">Добавляем компонент видеоплеера</h3><br/>
<p>Нужно заменить нашу заглушку на компонент, способный показывать видео с Ютуба. Воспользуемся компонентом из библиотеки <code>react-youtube-lite</code>. Его документацию и API можно найти в <a href="https://www.npmjs.com/package/react-youtube-lite" rel="nofollow noopener noreferrer">README</a>.</p><br/>
<p>Вспомним самое начало практики. Там мы видели зависимость на <code>react-youtube-lite</code>, объявленную в файле Gradle. Вот то место:</p><br/>
<pre><code class="kotlin">dependencies {
    // ...
    // Video Player (шаг 7)
    implementation(npm("react-youtube-lite", "1.0.1"))
    // ...
}</code></pre><br/>
<p>Вы понимаете правильно – NPM зависимости могут быть добавлены в Gradle проект с помощью функции <code>npm</code>. <code>yarn</code>, который вызывается Kotlin/JS Gradle плагином под капотом, позаботится о загрузке, установке и обновлении этих зависимостей.</p><br/>
<p>Когда мы хотим использовать NPM модули из Котлина, необходимо рассказать компилятору о сигнатурах: что можно вызывать, присваивать или читать. После этого все будет статически типизировано, и IDE сможет помогать нам писать обычный код на Котлине. Объявлять декларации для каждого внешнего модуля надо в отдельном файле. Создадим файл <code>ReactYouTube.kt</code> со следующим содержимым:</p><br/>
<pre><code class="kotlin">@file:JsModule("react-youtube-lite")
@file:JsNonModule

import react.*

@JsName("ReactYouTubeLite")
external val reactPlayer: RClass&lt;dynamic&gt;</code></pre><br/>
<p>Импорты и экспорты в JavaScript – относительно непростая тема, поэтому иногда бывает сложно найти правильную комбинацию аннотаций, чтобы компилятор Котлина импортировал все правильно. Последние две строчки в нашем случае – это эквивалент <code>require("react-youtube-lite").default</code> в JS. Они говорят компилятору: "мы уверены, что в рантайме тут получится компонент, соответствующий <code>RClass&lt;dynamic&gt;</code>".</p><br/>
<h4 id="tipizirovannye-obertki-dlya-komponenta">Типизированные обертки для компонента</h4><br/>
<p>Однако, оставив все в таком виде, мы откажемся от большого количества возможностей Котлина. Объявление <code>dynamic</code> типа говорит компилятору, что значение этого типа может быть любым. Компилятор не будет проверять такие объекты, а значит есть высокий риск, что что-то сломается во время исполнения (например, в проде).</p><br/>
<p>К счастью, мы уже видели, как в Котлине объявляются реактовские атрибуты (как <code>external</code> интерфейс), а их имена мы можем найти опять же в README библиотеки. Так что на самом деле написание типобезопасных деклараций – довольно простая задача. Мы можем объявить только те свойства, которые будем использовать – в первую очередь нам будет полезно задавать ссылку на видео. Поменяем декларацию видеоплеера вот так:</p><br/>
<pre><code class="kotlin">@file:JsModule("react-youtube-lite")
@file:JsNonModule

import react.*

@JsName("ReactYouTubeLite")
external val reactPlayer: RClass&lt;ReactYouTubeProps&gt;

external interface ReactYouTubeProps : RProps {
    var url: String
}</code></pre><br/>
<p>Самое время заменить скучный серый прямоугольник внутри компонента <code>VideoPlayer</code> на только что задекларированный настоящий плеер! Удалим тег <code>img</code> и заменим его на следующее:</p><br/>
<pre><code class="kotlin">reactPlayer {
    attrs.url = props.video.videoUrl
}</code></pre><br/>
<h3 id="dobavlyaem-knopki-shera">Добавляем кнопки шера</h3><br/>
<p>Получать удовольствие от докладов с KotlinConf лучше вместе (что является правдой и для многих других занятий). Кнопки шера – общепризнанный способ поделиться с друзьями и коллегами качественным контентом. Такие кнопки могут поддерживать, например, мессенджеры и электронную почту. Для кнопок есть уже существующие Реакт компоненты, например, из пакета <a href="https://github.com/nygardk/react-share/blob/master/README.md" rel="nofollow noopener noreferrer">react-share</a>. Этот пакет тоже уже объявлен в конфигурации Gradle:</p><br/>
<pre><code class="kotlin">dependencies {
    // ...
    // Share Buttons (шаг 7)
    implementation(npm("react-share", "~4.2.1"))
    // ...
}</code></pre><br/>
<p>Опять напишем декларации. Если посмотрим на <a href="https://github.com/nygardk/react-share/blob/master/demo/Demo.tsx" rel="nofollow noopener noreferrer">примеры</a> с ГитХаба, увидим, что кнопки состоят из двух компонентов: например, <code>EmailShareButton</code> и <code>EmailIcon</code>. И почти все из них имеют одинаковые атрибуты. Файл с декларациями получается примерно следующий; назовем его <code>ReactShare.kt</code>:</p><br/>
<pre><code class="kotlin">@file:JsModule("react-share")
@file:JsNonModule

import react.RClass
import react.RProps

@JsName("EmailIcon")
external val emailIcon: RClass&lt;IconProps&gt;

@JsName("EmailShareButton")
external val emailShareButton: RClass&lt;ShareButtonProps&gt;

@JsName("TelegramIcon")
external val telegramIcon: RClass&lt;IconProps&gt;

@JsName("TelegramShareButton")
external val telegramShareButton: RClass&lt;ShareButtonProps&gt;

external interface ShareButtonProps : RProps {
    var url: String
}

external interface IconProps : RProps {
    var size: Int
    var round: Boolean
}</code></pre><br/>
<p>Давайте добавим две кнопки над компонентом видеоплеера. Напишем следующий код перед вызовом <code>reactPlayer</code> (обернем в <code>styledDiv</code>, чтобы сделать расположение компонентов подходящим):</p><br/>
<pre><code class="kotlin">styledDiv {
    css {
        display = Display.flex
        marginBottom = 10.px
    }
    emailShareButton {
        attrs.url = props.video.videoUrl
        emailIcon {
            attrs.size = 32
            attrs.round = true
        }
    }
    telegramShareButton {
        attrs.url = props.video.videoUrl
        telegramIcon {
            attrs.size = 32
            attrs.round = true
        }
    }
}</code></pre><br/>
<p>Теперь можно проверить, что кнопки действительно работают. Если кликнуть по ним, должно открыться окно. Если же ничего не происходит, возможно, у вас включен скрывающий такие кнопки блокировщик рекламы.<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/1b8/38d/927/1b838d92717d355eb47cdc830848afad.png" alt="pair" data-src="https://habrastorage.org/getpro/habr/post_images/1b8/38d/927/1b838d92717d355eb47cdc830848afad.png"/></p><br/>
<p>Если хотите, можете написать декларации для других кнопок в этой библиотеке и тоже добавить их на экран.</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>step-06-packages-from-npm</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-06-packages-from-npm" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep8shag-8-ispolzuem-vneshnee-rest-apia">Шаг 8. Используем внешнее REST API</h2><br/>
<p>Вас может расстраивать, что до сих пор мы показываем только очень ограниченный захардкоженный список видео. Давайте теперь заменим эти данные реальными, получать которые мы будем из REST API.</p><br/>
<p>Для этой практики мы создали небольшое API, доступное по ссылке <a href="https://my-json-server.typicode.com/kotlin-hands-on/kotlinconf-json/videos/1" rel="nofollow noopener noreferrer">https://my-json-server.typicode.com/kotlin-hands-on/kotlinconf-json/videos/1</a>. У этого API только одна ручка – <code>videos</code>, которая может возвращать информацию видео по его номеру. Попробуйте поделать запросы к этому API из браузера. Вы увидите, что возвращаемые объекты имеют ту же структуру, что и объекты <code>Video</code> в нашем коде (какое совпадение <code>;)</code>). В следующей секции мы обсудим, как приложение может запрашивать эти данные и преобразовывать их в наши котлиновские объекты.</p><br/>
<h3 id="ispolzovanie-funkcionalnosti-js-iz-kotlina">Использование функциональности JS из Котлина</h3><br/>
<p>Даже без добавления библиотек браузеры дают множество возможностей. В стандартной библиотеке Kotlin/JS есть обертки как раз для этих стандартных браузерных вызовов, позволяющие делать эти вызовы комфортно и типобезопасно прямо из кода на Котлине. Мы воспользуемся обертками для <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="nofollow noopener noreferrer">Fetch API</a>, чтобы делать HTTP запросы для обращения к REST API.</p><br/>
<p>Типичный способ создавать асинхронные программы в экосистеме JavaScript – использовать колбеки. При этом приходится раз за разом дожидаться выполнения промисов, заключая функции внутрь функций, которые в свою очередь тоже могут быть заключены в других функциях. Чем сложнее код, тем тяжелее будет синтаксис из-за отступов и скобок. Код будет съезжать вправо, его будет сложнее читать и понимать весь поток выполнения, как нам, так и другим разработчикам. Несмотря на эти недостатки, в нашем случае код с колбеками может быть довольно простым:</p><br/>
<pre><code class="kotlin">window.fetch("https://url...").then {
    it.json().then {
        it.unsafeCast&lt;Video&gt;()
        //...
    }
}</code></pre><br/>
<p><strong>Но мы будем использовать другой подход</strong>. Обратимся к котлиновским корутинам, более красивому и структурированному способу добиться той же цели.</p><br/>
<h3 id="korutiny-vmesto-kolbekov">Корутины вместо колбеков</h3><br/>
<p>Корутины и структурированная конкурентность (structured concurrency) – гигантская тема в Котлине. Если вы хотите хорошо в них разобраться, попробуйте пройти <a href="https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/" rel="nofollow noopener noreferrer">практику по корутинам</a>. Сейчас же мы обсудим их только поверхностно. Начнем с добавления библиотеки корутин в зависимости нашего проекта.</p><br/>
<p>Как и другие зависимости в нашей практики, соответствующий Gradle код уже присутствует в конфигурации еще с момента начальной настройки проекта:</p><br/>
<pre><code class="kotlin">dependencies {
    //...
    // Coroutines (шаг 8)
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9")
}</code></pre><br/>
<p>Давайте теперь запросим информацию о видео, используя корутины!</p><br/>
<h3 id="zaprashivaem-pervoe-video">Запрашиваем первое видео</h3><br/>
<p>Внутри <code>App.kt</code> или в новом файле, напишем функцию, которая будет получать видео из REST API:</p><br/>
<pre><code class="kotlin">suspend fun fetchVideo(id: Int): Video {
    val response = window
        .fetch("https://my-json-server.typicode.com/kotlin-hands-on/kotlinconf-json/videos/$id")
        .await()
        .json()
        .await()
    return response as Video
}</code></pre><br/>
<p>С помощью быстрых исправлений импортируем нужные объекты и функции. Или добавим импорты наверху файла вручную:</p><br/>
<pre><code class="kotlin">import kotlinx.browser.window
import kotlinx.coroutines.*</code></pre><br/>
<p>Попробуем понять, что происходит в этой <em>suspend функции</em>. Мы запрашиваем информацию о видео с помощью функции <code>fetch</code>, подставляя <code>id</code> видео в ссылку на API. Ждем готовности ответа (<code>await</code>), преобразуем ответ к JSON, опять ждем уже готовности преобразования. После этого мы кастуем результат к объявленному в ходе нашей практики <code>external interface Video</code> и возвращаем его из функции. Скорее всего, IDE подсветит каст как непроверенный – но это нормально при использовании JavaScript вызовов типа <code>fetch</code>: компилятор <em>не может быть уверен наверняка</em>, что на этом месте получится экземпляр <code>Video</code>. Компилятор вынужден верить разработчику. <strong>Примечание переводчика</strong>: чтобы убирать такие предупреждения, можно либо заглушать их с помощью аннотации <code>@Suppress</code>, либо использовать метод <code>unsafeCast</code> (<code>response.unsafeCast&lt;Video&gt;()</code>).</p><br/>
<p>Обсудим происходящее чуть подробнее. Вызовы функций <code>window.fetch</code> и <code>json</code> на самом деле возвращают промис. Мы могли бы передать колбек, который выполнится при готовности результата промиса. Однако так как в нашем проекте доступны корутины, мы можем вместо возни с колбеками просто подождать (<code>await</code>) готовности результата. Таким образом, написанный код выглядит последовательным, но остается неблокирующим. Когда вызывается <code>await</code>, на самом деле выполнение всей функции приостанавливается (отсюда требование помечать такую функцию как <code>suspend</code>). Когда результат промиса готов, выполнение функции продолжается.</p><br/>
<h3 id="ispolzuem-suspend-funkciyu">Используем suspend функцию</h3><br/>
<p>Давайте наконец запросим список видео, например, взяв первые 25. Для этого объявим функцию <code>fetchVideos</code>, вызывающую предыдущую функцию 25 раз. Так как мы хотим одновременного выполнения запросов, мы можем использовать еще одну функцию корутин для запуска suspend кода – <code>async</code>. Тогда реализация будет выглядеть примерно так:</p><br/>
<pre><code class="kotlin">suspend fun fetchVideos(): List&lt;Video&gt; = coroutineScope {
    (1..25).map { id -&gt;
        async {
            fetchVideo(id)
        }
    }.awaitAll()
}</code></pre><br/>
<p>Для правильности <a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency" rel="nofollow noopener noreferrer">структурированной конкурентности</a> мы оборачиваем весь код функции в <code>coroutineScope</code>. Внутри мы запускаем 25 асинхронных задач, по одной на запрос, и ждем выполнения их всех.</p><br/>
<p>Воспользуемся возможностью еще раз напомнить о <a href="https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/" rel="nofollow noopener noreferrer">практике по корутинам</a>, где обо всем этом рассказывается намного более полно.</p><br/>
<p>После получения реальных данных настает время использовать их в нашем приложении. Чтобы сделать это, поменяем функцию <code>init</code> нашего класса <code>App</code>:</p><br/>
<pre><code class="kotlin">override fun AppState.init() {
    unwatchedVideos = listOf()
    watchedVideos = listOf()

    val mainScope = MainScope()
    mainScope.launch {
        val videos = fetchVideos()
        setState {
            unwatchedVideos = videos
        }
    }
}</code></pre><br/>
<p>Заметьте, что хотя мы внутри функции <code>init</code>, мы все равно вызываем <code>setState</code> для изменения <code>unwatchedVideos</code> внутри корутины. Это происходит из-за того, что наш код неблокирующий, и приложение скорее всего уже отрендерило пустой список, записанный в <code>unwatchedVideos</code> изначально. Вызывая <code>setState</code>, мы подскажем рендереру Реакта, что может быть необходима перерисовка.</p><br/>
<p>По возвращении в браузер мы наконец должны увидеть настоящий список видео:<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/e98/63c/4b8/e9863c4b8f99d4ae60691fbf15bfe1a8.png" alt="real data" data-src="https://habrastorage.org/getpro/habr/post_images/e98/63c/4b8/e9863c4b8f99d4ae60691fbf15bfe1a8.png"/></p><br/>
<p>На этом часть по разработке в этой практике подошла к концу. Мы прошли долгий путь, от начальной производной "Hello, World" до вполне полноценного органайзера видео.</p><br/>
<p>Не отключайтесь, если хотите узнать, как бандлить приложение для использования в продакшене, и как дать приложение в руки пользователям, опубликовав его в облаке.</p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>step-07-using-external-rest-api</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/step-07-using-external-rest-api" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep9shag-9-deploim-v-prodakshen-i-v-oblakoa">Шаг 9. Деплоим в продакшен и в облако</h2><br/>
<p>После создания приложения хорошо бы его выложить для широкой общественности.</p><br/>
<h3 id="upakovka-sobrannogo-prilozheniya">Упаковка собранного приложения</h3><br/>
<p>Чтобы упаковать все необходимые файлы приложения для продакшена, достаточно просто запустить Gradle задачу <code>build</code> в тул-окне IntelliJ IDEA или с помощью команды <code>./gradlew build</code>. Она сгенерирует оптимизированный упакованный проект, применяя, например, DCE (dead code elimination – удаление неиспользуемого кода).</p><br/>
<p>Необходимо подождать, после чего все нужные статические файлы будут созданы в папке <code>build/distributions</code>. Там будут JS файлы, HTML и другие ресурсы, которые необходимы приложению. Содержимое этой папки готово к деплою, то есть можно, например, положить эти файлы в любой статический HTTP сервер, добавить их на GitHub Pages или захостить на любом облаке.</p><br/>
<h3 id="deploim-na-heroku">Деплоим на Heroku</h3><br/>
<p>Heroku дает довольно легко развернуть приложение на своем домене. Их бесплатный тариф должен быть достаточен при обучении; его точно хватит, чтобы выложить небольшое приложение и похвастаться перед друзьями и коллегами.</p><br/>
<p>После <a href="https://signup.heroku.com/" rel="nofollow noopener noreferrer">создания аккаунта</a> и <a href="https://devcenter.heroku.com/articles/heroku-cli" rel="nofollow noopener noreferrer">установки клиента и входа в него</a> мы можем создать git репозиторий и Heroku приложение. Это делается такими командами в терминале:</p><br/>
<pre><code class="plaintext">git init
heroku create
git add .
git commit -m "initial commit"</code></pre><br/>
<p>В отличие от обычного JVM приложения, которое можно запустить на Heroku (например, написанное на Ktor или Spring Boot), наше приложение генерирует статичные файлы, которые надо раздавать сервером. Поэтому нужно соответствующе настроить Heroku:</p><br/>
<pre><code class="plaintext">heroku buildpacks:set heroku/gradle
heroku buildpacks:add https://github.com/heroku/heroku-buildpack-static.git</code></pre><br/>
<p>Для выполнения <code>heroku/gradle</code> необходимо иметь задачу <code>stage</code> в Gradle проекте. К счастью, это эквивалент задачи <code>build</code>, поэтому очень просто создать еще одну задачу, которая будет вызывать необходимую:</p><br/>
<pre><code class="kotlin">// Heroku Deployment (шаг 9)
tasks.register("stage") {
    dependsOn("build")
}</code></pre><br/>
<p>Еще нужно сконфигурировать <code>buildpack-static</code>, добавив в проект корневой файл <code>static.json</code>. Он должен содержать единственное свойство <code>root</code>:</p><br/>
<pre><code class="json">{
    "root": "build/distributions"
}</code></pre><br/>
<p>Теперь можно вызвать деплой, например, такой последовательностью команд:</p><br/>
<pre><code class="plaintext">git add -A
git commit -m "add stage task and static content root configuration"
git push heroku master</code></pre><br/>
<blockquote>Если вы пушите не master ветку (а, например, ветку <code>step*</code> из репозитория с состоянием проекта), то нужно поменять команду, чтобы она продолжала пушить в master на Heroku (например, так: <code>git push heroku step-08-deploying-to-production:master</code>).</blockquote><p>Если все прошло по плану, вы увидите ссылку, по которой можно достучаться до нашего приложения во всемирной паутине!<br/>
<img src="https://habrastorage.org/r/w1560/getpro/habr/post_images/29c/72a/caa/29c72acaab8d818c7251d70c01313088.png" alt="heroku" data-src="https://habrastorage.org/getpro/habr/post_images/29c/72a/caa/29c72acaab8d818c7251d70c01313088.png"/></p><br/>
<blockquote>Состояние проекта после выполнения этого шага доступно в ветке <code>final</code> <a href="https://github.com/kotlin-hands-on/web-app-react-kotlin-js-gradle/tree/final" rel="nofollow noopener noreferrer">в репозитории</a>.</blockquote><br/>
<h2 id="a-namestep10shag-10-v-dopolnenie-sovremennyy-reakt-s-hukamia">Шаг 10. В дополнение: современный Реакт с хуками</h2><br/>
<p>Если вы прошли всю практику и хотите попробовать еще чего-нибудь крутого, в дополнение расскажем о более современных фичах Реакта.</p><br/>
<p>В React 16.8 появились <a href="https://reactjs.org/docs/hooks-intro.html" rel="nofollow noopener noreferrer">хуки</a>. Они позволяют использовать состояние и другие возможности Реакта без написания классов для компонентов. Хорошая новость: котлиновские обертки Реакта поддерживают и хуки!</p><br/>
<p>Чтобы понять, как устроен этот новый способ написания Реакт компонентов и как эта концепция реализована в Котлине, мы рассмотрим несколько самодостаточных примеров о двух самых используемых встроенных в Реакт хуках – state и effect. <strong>Как и другие хуки, эти два используются внутри функциональных компонентов</strong>.</p><br/>
<h3 id="funkcionalnye-komponenty">Функциональные компоненты</h3><br/>
<p>Идейно, реактовские функциональные компоненты сами по себе не очень сложны. Они представлены в виде функций, которые содержат инструкции для рендеринга компонента. Свойства для компонента передаются в саму функцию – они не хранятся в <code>this</code>. Простенький функциональный компонент можно написать на Котлине, например, вот так:</p><br/>
<pre><code class="kotlin">external interface WelcomeProps : RProps {
    var name: String
}

val welcome = functionalComponent&lt;WelcomeProps&gt; { props -&gt; 
    h1 {
        +"Hello, ${props.name}"
    }
}</code></pre><br/>
<p>Как и для классовых компонентов, мы определяем свойства внутри <code>external interface</code>. Тип свойства для функционального компонента мы аналогично определяем в дженерике. Переданная в билдер <code>functionalComponent</code> функция может напоминать метод <code>render</code> для классовых компонентов.</p><br/>
<p>Использовать этот компонент можно как обычно: достаточно передать его внутрь <code>child</code>:</p><br/>
<pre><code class="kotlin">child(welcome) {
    attrs.name = "Kotlin"
}</code></pre><br/>
<p>Также уже знакомым вам образом можно реализовать более лаконичную обертку:</p><br/>
<pre><code class="kotlin">fun RBuilder.welcome(handler: WelcomeProps.() -&gt; Unit) = child(welcome) {
    attrs.handler()
}</code></pre><br/>
<p>Мы проделывали аналогичное действие на шаге 4. После этого для вставки компонента на страницу достаточно написать <code>welcome { name = "Kotlin" }</code>.</p><br/>
<p>Как видите, пока что функциональные компоненты не дают нам чего-то нового. Но их полный потенциал раскрывается при использовании хуков.</p><br/>
<h3 id="huk-state">Хук State</h3><br/>
<p>Чтобы хранить состояние в функциональном компоненте, можно использовать соответствующий хук. В качестве примера рассмотрим следующую реализацию счетчика:</p><br/>
<pre><code class="kotlin">val counter = functionalComponent&lt;RProps&gt; {
    val (count, setCount) = useState(0)
    button {
        attrs.onClickFunction = { setCount(count + 1) }
        +"$count"
    }
}</code></pre><br/>
<p>Есть тройка ключевых моментов, которые происходят в примере:</p><br/>
<ul>
<li><code>useState</code> вызывается с изначальным значением <code>0</code> – поэтому тип этого элемента состояния выводится как <code>Int</code>. Также можно указать тип явно, что будет полезно, если придется работать с зануляемым значением (<code>useState&lt;String?&gt;(null)</code>).</li>
<li>Вызов <code>useState</code> возвращает пару, которая сразу же деструктурируется:<br/>
<ol>
<li>Ссылка на текущее состояние (здесь это <code>count</code> типа <code>Int</code>);</li>
<li>Функция для изменения состояния (здесь это <code>setCount</code> типа <code>RSetState&lt;Int&gt; /* = (Int) -&gt; Unit */</code>).</li>
</ol></li>
<li>В отличие от классовых компонентов, изменение состояния не требуется производить внутри <code>setState</code>.</li>
</ul><br/>
<p>Реакт заботится о правильном жизненном цикле компонента, поэтому переменная <code>count</code> будет инициализирована только один раз, а последующие рендеринги будут использовать актуальное состояние. В итоге писать функциональные компоненты несколько проще, чем классовые, так как функциональность получается аналогичной, но код более компактный.</p><br/>
<p>Больше о хуке State можно узнать в <a href="https://reactjs.org/docs/hooks-state.html" rel="nofollow noopener noreferrer">официальной документации</a>.</p><br/>
<p><strong>Примечание от переводчика</strong>: в Котлине также доступна более удобная работа с <code>useState</code> – как с изменяемой переменной-делегатом. Тогда код упрощается, однако, становится менее похожим на традиционный Реакт:</p><br/>
<pre><code class="kotlin">val counter = functionalComponent&lt;RProps&gt; {
    var count by useState(0)
    button {
        attrs.onClickFunction = { ++count }
        +"$count"
    }
}</code></pre><br/>
<h3 id="huk-effect">Хук Effect</h3><br/>
<p>Хук эффекта приходит на помощь, когда необходимо совершить какое-нибудь побочное действие внутри компонента – такое как вызов API или установление WebSocket соединения. Для демонстрации мы реализовали следующий компонент, который запрашивает случайный факт и по приходе ответа отображает его в теге <code>h3</code>:</p><br/>
<pre><code class="kotlin">val randomFact = functionalComponent&lt;RProps&gt; {
    val (randomFact, setRandomFact) = useState&lt;String?&gt;(null)
    useEffect(emptyList()) {
        GlobalScope.launch {
            val fortyTwoFact = window.fetch("http://numbersapi.com/42").await().text().await()
            setRandomFact(fortyTwoFact)
        }
    }
    h3 { +(randomFact ?: "Fetching...") }
}</code></pre><br/>
<p>Чтобы следить за результатом запроса, мы используем хук состояния, почти такой же, как в предыдущем параграфе. Сам запрос мы совершаем внутри <code>useEffect</code>, где при получении результата вызываем <code>setRandomFact</code> для сохранения этого текста в состоянии.</p><br/>
<p>Заметьте, что <code>useEffect</code> вызывается с двумя параматрами. Второй – это функция, а первый – <em>зависимости</em> эффекта. Зависимости определяют, какие свойства и состояния должны измениться, чтобы запустить переданную в <code>useEffect</code> функцию вновь. В нашем случае мы хотим сделать только один запрос к API независимо от других событий в приложении. Поэтому мы передаем пустой список в качестве зависимостей.</p><br/>
<p>Если же не передавать пустой список, то в таком случае хук эффекта будет вызываться после каждого вызова <code>setRandomFact</code>, так что получится бесконечный цикл.</p><br/>
<p>Больше об этих и других тонкостях хука Effect, а также о его соотнесении с "классическим" жизненным циклом в Реакте, можно опять же узнать в <a href="https://reactjs.org/docs/hooks-effect.html" rel="nofollow noopener noreferrer">официальной документации</a>.</p><br/>
<h3 id="domashnee-zadanie">Домашнее задание</h3><br/>
<p>Если хотите, можете конвертировать какие-нибудь компоненты нашего приложения, например, <code>videoList</code>, в функциональные компоненты с хуками. Хук <code>useState</code> пригодится в большинстве компонентов, а вот <code>useEffect</code> будет важен при общении с внешним API, которое мы сделали на шаге 8.</p><br/>
<p>Классовые и функциональные компоненты могут жить припеваючи в одном Реакт приложении, поэтому вы можете просто добавить <em>новый</em> функциональный компонент в наше приложение.</p><br/>
<h2 id="a-namestep11shag-11-chto-dalshea">Шаг 11. Что дальше?</h2><br/>
<h3 id="dopolnitelnye-fichi-prilozheniya">Дополнительные фичи приложения</h3><br/>
<p>Конечно же, сделанное нами приложение далеко не идеально. Однако этот результат вы можете использовать как стартовую точку для изучения дальнейших тем в сфере Реакта, Kotlin/JS и других близких технологий.</p><br/>
<h4 id="poisk">Поиск</h4><br/>
<p>Было бы отлично иметь возможность фильтровать список видео по заголовку или докладчику. Для этого хорошо подойдет поисковая строка, которую можно реализовать в качестве дополнительного функционала. Вы можете изучить, как <a href="https://reactjs.org/docs/forms.html" rel="nofollow noopener noreferrer">предлагается работать с HTML формами в Реакте</a>, и сразу же применить полученные знания на практике.</p><br/>
<h4 id="persistentnost">Персистентность</h4><br/>
<p>Наше приложение теряет состояние просмотренного контента каждый раз при перезагрузке страницы. Возможно, настало время сделать бэк-энд. Познакомьтесь с каким-нибудь веб фреймворком, поддерживаемым Котлином (таким как <a href="https://ktor.io/" rel="nofollow noopener noreferrer">Ktor</a>), и попробуйте написать сервер для нашего приложения, который будет сохранять список просмотренных и непросмотренных видео. Или же можно обойтись без бэк-энда и <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="nofollow noopener noreferrer">сохранять информацию прямо на клиенте</a>.</p><br/>
<h4 id="slozhnye-apis">Сложные APIs</h4><br/>
<p>В прекрасном мире веба есть множество датасетов и APIs, с которыми можно поиграться. Почему бы не создать фотогалерею для <a href="https://thecatapi.com/" rel="nofollow noopener noreferrer">фоток котеек</a>? Или разукрасить свою жизнь с помощью <a href="https://unsplash.com/developers" rel="nofollow noopener noreferrer">бесплатного сервиса с разнообразными фотографиями</a> (<strong>примечание переводчика</strong>: не забудьте обратить внимание на <a href="https://unsplash.com/license" rel="nofollow noopener noreferrer">лицензию</a>)? Количество данных, которые можно затащить в свое приложение, просто неисчислимо!</p><br/>
<h3 id="stili-poluchshe-otzyvchivost-i-setki">Стили получше: отзывчивость и сетки</h3><br/>
<p>На данный момент наше приложение в экстремальных ситуациях выглядит кривовато, например, в узких окнах и на экранах смартфонов. Как раз можно изучить CSS сетки (grids) и сделать приложение отзывчивым к размерам страницы (бонусная задачка: не использовать медиавыражения).</p><br/>
<h3 id="drugie-biblioteki">Другие библиотеки</h3><br/>
<p>В репозитории <a href="https://github.com/JetBrains/kotlin-wrappers" rel="nofollow noopener noreferrer">kotlin-wrappers</a> можно найти больше официальных котлиновских оберток для разных JS библиотек, а также первоначальную информацию по их использованию. Например (но не ограничиваясь):</p><br/>
<ul>
<li><a href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-redux" rel="nofollow noopener noreferrer">React-Redux</a>.</li>
<li><a href="https://github.com/JetBrains/kotlin-wrappers/tree/master/kotlin-react-router-dom" rel="nofollow noopener noreferrer">React-Router-DOM</a>.</li>
</ul><br/>
<h3 id="soobschestvo-pomosch-i-reshenie-problem">Сообщество, помощь и решение проблем</h3><br/>
<p>Лучший способ получить помощь по созданию Реакт приложений на Котлине – посетить <a href="https://youtrack.jetbrains.com/issues/CRKA" rel="nofollow noopener noreferrer">YouTrack</a>. Если вы не можете найти вашу проблему, не бойтесь создать еще один тикет. Также можно присоединиться к <a href="https://surveys.jetbrains.com/s3/kotlin-slack-sign-up" rel="nofollow noopener noreferrer">официальному котлиновскому Slack</a>. Там есть много каналов, включая <code>#javascript</code> и <code>#react</code>.</p><br/>
<h3 id="dalneyshee-izuchenie-korutin">Дальнейшее изучение корутин</h3><br/>
<p>Мы совсем чуть-чуть потрогали мощные концепции корутин, которые стоит использовать во многих приложениях. Если вам интересно узнать больше о написании конкурентного кода, предлагаем начать с <a href="https://play.kotlinlang.org/hands-on/Introduction%20to%20Coroutines%20and%20Channels/01_Introduction" rel="nofollow noopener noreferrer">практики по корутинам</a>.</p><br/>
<h3 id="dalneyshee-izuchenie-reakta">Дальнейшее изучение Реакта</h3><br/>
<p><a href="https://reactjs.org/docs/" rel="nofollow noopener noreferrer">Официальная документация по Реакту</a> написана довольно исчерпывающе и вообще хорошо. Вы теперь знаете базовые идеи Реакта и их использование из Котлина, поэтому надеемся, что вы сможете разобраться с остальными концепциями из официальной документации и перевести их на Котлин.</p><br/>
<p>Возможно, в будущем вы даже станете профессионалом котлиновского Реакта!</p><br/>
<h2 id="posleslovie-ot-perevodchika">Послесловие от переводчика</h2><br/>
<p>Спасибо, что дошли до конца! Если вы оценили Kotlin/JS и планируете продолжать его изучение, следующим шагом я бы порекомендовал научиться читать JS, а в особенности JSX – примеры по Реакту используют именно это, поэтому нужно понимать, как переписывать их на Котлин.</p><br/>
<p>Предрекая вопросы, расскажу, почему я сам сделал выбор в пользу Kotlin DSL. В отличие от отдельно придуманного синтаксиса JSX со своими особенностями, Kotlin DSL довольно привычен и интуитивен для тех, кто уже работал с Котлином. Здесь, как говорилось, можно использовать обычные котлиновские конструкции вроде циклов, а для подключения Реакта к своему проекту достаточно подключить библиотеку – настраивать компиляцию не надо. В общем, на Котлине писать выходит более комфортно, хотя и все еще менее производительно. С нетерпением жду развития Kotlin/JS и сообщества вокруг него!</p></div></div></div><!----><!----></div><!----><div class="tm-article-poll-container"><!--[--><div class="tm-article-poll tm-article-poll_variant-bordered"><div class="tm-notice tm-notice_positive tm-article-poll__notice"><!----><div class="tm-notice__inner"><!----><div class="tm-notice__content" data-test-id="notice-content"><!--[--><span>Только зарегистрированные пользователи могут участвовать в опросе. <a rel="nofollow" href="/kek/v1/auth/habrahabr/?back=/ru/articles/555744/&hl=ru">Войдите</a>, пожалуйста.</span><!--]--></div></div></div><!--[--><div class="tm-article-poll__header">Как вам идея таких переводов в целом и в частности?</div><div class="tm-article-poll__answers"><!--[--><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent tm-article-poll__answer-percent_winning">75% </span><span class="tm-article-poll__answer-label">Переводы английских туториалов на русский нужны; этот перевод неплохой, продолжай писать подобное.</span><span class="tm-article-poll__answer-votes">30</span></div><div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress tm-article-poll__answer-progress_winning" style="width: 75%"></div></div></div><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent">2.5% </span><span class="tm-article-poll__answer-label">Переводы туториалов нужны, но качество этого перевода низкое.</span><span class="tm-article-poll__answer-votes">1</span></div><div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress" style="width: 2.5%"></div></div></div><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent">17.5% </span><span class="tm-article-poll__answer-label">Переводы туториалов не нужны: лучше сразу в оригинале читать. Но этот перевод хороший.</span><span class="tm-article-poll__answer-votes">7</span></div><div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress" style="width: 17.5%"></div></div></div><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent">2.5% </span><span class="tm-article-poll__answer-label">Переводы туториалов не нужны, а переводчик этого туториала зря потратил время.</span><span class="tm-article-poll__answer-votes">1</span></div><div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress" style="width: 2.5%"></div></div></div><div class="tm-article-poll__answer"><div class="tm-article-poll__answer-data"><span class="tm-article-poll__answer-percent">2.5% </span><span class="tm-article-poll__answer-label">Другое мнение (в комментариях/в личке/при себе).</span><span class="tm-article-poll__answer-votes">1</span></div><div class="tm-article-poll__answer-bar"><div class="tm-article-poll__answer-progress" style="width: 2.5%"></div></div></div><!--]--></div><div class="tm-article-poll__stats"> Проголосовали 40 пользователей.   Воздержались 8 пользователей. </div><!--]--></div><!--]--></div></div><!--]--><!----><div class="tm-article-presenter__meta" data-test-id="article-meta-links"><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Теги:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[javascript]" class="tm-tags-list__link"><span>javascript</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[reactjs]" class="tm-tags-list__link"><span>reactjs</span></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/search/?target_type=posts&amp;order=relevance&amp;q=[kotlin]" class="tm-tags-list__link"><span>kotlin</span></a><!--]--></li><!--]--><!----></ul></div><div class="tm-separated-list tm-article-presenter__meta-list"><span class="tm-separated-list__title">Хабы:</span><ul class="tm-separated-list__list"><!--[--><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/javascript/" class="tm-hubs-list__link"><!--[--><span>JavaScript</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/kotlin/" class="tm-hubs-list__link"><!--[--><span>Kotlin</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/reactjs/" class="tm-hubs-list__link"><!--[--><span>ReactJS</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/web_design/" class="tm-hubs-list__link"><!--[--><span>Веб-дизайн</span><!--]--></a><!--]--></li><li class="tm-separated-list__item"><!--[--><a href="/ru/hubs/webdev/" class="tm-hubs-list__link"><!--[--><span>Веб-разработка</span><!--]--></a><!--]--></li><!--]--><!----></ul></div></div><!----><!--]--></article><!--]--></div><!----></div><div style="" class="tm-article-sticky-panel" data-test-id="article-sticky-panel"><div class="tm-data-icons tm-data-icons tm-data-icons_space-big tm-article-sticky-panel__icons" data-test-id="article-stats-icons"><div class="tm-article-rating tm-data-icons__item"><div class="tm-votes-meter tm-article-rating__votes-switcher"><svg class="tm-svg-img tm-votes-meter__icon tm-votes-meter__icon tm-votes-meter__icon_appearance-article" height="24" width="24"><title>Всего голосов 8: ↑7 и ↓1</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-rating"></use></svg><span class="tm-votes-meter__value tm-votes-meter__value_positive tm-votes-meter__value_appearance-article tm-votes-meter__value_rating tm-votes-meter__value" data-test-id="votes-meter-value" title="Всего голосов 8: ↑7 и ↓1">+6</span></div><!--teleport start--><!--teleport end--><!----></div><!----><!----><button class="bookmarks-button tm-data-icons__item" title="Добавить в закладки" type="button"><span class="tm-svg-icon__wrapper bookmarks-button__icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Добавить в закладки</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-favorite"></use></svg></span><span class="bookmarks-button__counter" title="Количество пользователей, добавивших публикацию в закладки">78</span></button><div class="tm-sharing tm-data-icons__item" title="Поделиться"><button class="tm-sharing__button" type="button"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" class="tm-sharing__icon"><path fill="currentColor" d="M13.8 13.8V18l7.2-6.6L13.8 5v3.9C5 8.9 3 18.6 3 18.6c2.5-4.4 6-4.8 10.8-4.8z"></path></svg></button><!--teleport start--><!--teleport end--></div><div class="tm-article-comments-counter-link tm-data-icons__item" title="Читать комментарии"><a href="/ru/articles/555744/comments/" class="tm-article-comments-counter-link__link" data-test-id="counter-comments"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value">7</span><!--]--></a><!----></div><!--[--><!--[--><!--[--><!----><!--]--><!--]--><!--]--><!--teleport start--><!--teleport end--><!----></div></div></div><!--[--><!--]--><div class="tm-article-presenter__footer"><!--[--><!--[--><div class="tm-article-blocks"><!----><!--[--><section class="tm-block tm-block tm-block_spacing-bottom"><!----><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-balanced"><!--[--><div class="tm-article-author" data-test-id="article-author-info" data-async-called="true"><!--[--><!--]--><div class="tm-user-card tm-user-card tm-user-card_variant-article tm-article-author__user-card" data-async-called="true"><div class="tm-user-card__info-container"><div class="tm-user-card__header"><div class="tm-user-card__header-data"><a href="/ru/users/SerVB/" class="tm-user-card__userpic tm-user-card__userpic_size-40"><div class="tm-entity-image"><!--[--><img alt="" class="tm-entity-image__pic" src="https://assets.habr.com/habr-web/img/avatars/051.png"><!--]--></div></a><div class="tm-user-card__meta"><div class="tm-counter-container tm-karma tm-karma" title=" 8 голосов "><div class="tm-counter-container__header"><!--[--><div class="karma-display positive" data-v-7635202e>6</div><!----><!--]--></div><div class="tm-counter-container__footer"><!--[--><div class="tm-karma__text">Карма</div><!--teleport start--><!--teleport end--><!--]--></div></div><div class="tm-counter-container" title="Рейтинг пользователя"><div class="tm-counter-container__header"><!--[--><!--[--><!--]--><div class="tm-votes-lever tm-votes-lever tm-votes-lever_appearance-rating"><!----><div class="tm-votes-lever__score tm-votes-lever__score_appearance-rating tm-votes-lever__score"><!--[--><span><span class="tm-votes-lever__score-counter tm-votes-lever__score-counter_rating tm-votes-lever__score-counter" data-test-id="votes-score-counter">0</span></span><!--]--></div><!----></div><!--]--></div><div class="tm-counter-container__footer"><!--[--><span class="tm-rating__text tm-rating__text">Рейтинг</span><!--]--></div></div></div></div></div><div class="tm-user-card__info tm-user-card__info_variant-article tm-user-card__info"><div class="tm-user-card__title tm-user-card__title_variant-article tm-user-card__title"><!----><a href="/ru/users/SerVB/" class="tm-user-card__nickname tm-user-card__nickname tm-user-card__nickname_variant-article"> @SerVB</a><!----></div><p class="tm-user-card__short-info tm-user-card__short-info_variant-article tm-user-card__short-info" data-test-id="user-card-speciality">Пользователь</p></div></div><!----><div class="tm-user-card__buttons tm-user-card__buttons_variant-article tm-user-card__buttons"><!----><div class="tm-user-card__button"><div class="tm-button-follow tm-user-card__button-follow"><!----><button class="tm-button-follow__button tm-button-follow__button_big" data-test-id="follow-button" type="button">Подписаться</button></div></div><!----><div class="tm-user-card__button tm-user-card__button_write" data-test-id="user-card-conversations"><svg class="tm-svg-img tm-user-card__button-icon" height="16" width="16"><title>Отправить сообщение</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#mail"></use></svg></div><!----></div><!----></div><div class="tm-article-author__user-contacts" data-test-id="author-contacts"><!----><!----><!----></div></div><!--]--></div><!--]--><!----></section><!----><!--[--><div class="banner-wrapper leaderboard tm-page-article__banner" style="--467224fc:200px;--58ff5eba:auto;" data-v-ad758baa><!--[--><div class="placeholder-wrapper placeholder" data-v-ad758baa><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="adfox-banner-placeholder leaderboard" data-v-12f7bcca><div class="image loads" data-v-12f7bcca></div><div class="lines" data-v-12f7bcca><div class="line loads" data-v-12f7bcca></div><div class="line loads" data-v-12f7bcca></div><div class="line loads" data-v-12f7bcca></div></div></div><!----></div><div id="adfox_164725660339535756" class="tm-adfox-banner" data-v-ad758baa></div><!--]--></div><!--]--><!--]--><div class="tm-article-blocks__comments"><div id="publication-comments" class="tm-article-page-comments"><div><!--[--><div class="tm-article-comments-counter-link tm-article-comments-counter-button"><a href="/ru/articles/555744/comments/" class="tm-article-comments-counter-link__link tm-article-comments-counter-link__link_button-style" data-test-id="counter-comments"><!--[--><svg class="tm-svg-img tm-article-comments-counter-link__icon tm-article-comments-counter-link__icon_contrasted" height="24" width="24"><title>Комментарии</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#counter-comments"></use></svg><span class="tm-article-comments-counter-link__value tm-article-comments-counter-link__value_contrasted"> Комментарии 7 </span><!--]--></a><!----></div><!--]--></div></div></div><!--[--><!--[--><!--]--><section class="tm-block tm-block tm-block_spacing-bottom"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title tm-block__title_variant-large">Публикации</h2><!--[--><!--]--></div><!----></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-condensed-slim"><!--[--><!--[--><div class="tm-tabs tm-tabs"><div class=""><!--[--><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_active tm-tabs__tab-link_slim tm-tabs__tab-link">Лучшие за сутки</button></span><span class="tm-tabs__tab-item"><button class="tm-tabs__tab-link tm-tabs__tab-link_slim tm-tabs__tab-link">Похожие</button></span><!--]--></div><!----></div><div class="similar-and-daily__tab-view"><div class="daily-articles-list"><ul class="tm-article-card-list"><!--[--><!--]--><div class="tm-bordered-card"><!----><!--[--><!--]--></div></ul><div class="daily-articles-block__button-container"><button class="btn btn_transparent btn_small tm-button tm-button_color-horizon" type="button"><!--[--><!--[-->Показать лучшие за всё время<!--]--><!--]--></button></div></div><!----></div><!--]--><!--]--></div><!--]--><!----></section><!--[--><section class="tm-block tm-block tm-block_spacing-around tm-stories-block" data-navigatable tabindex="0" data-async-called="true"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Истории</h2><!--[--><!--]--></div><!----></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-equal"><!--[--><div class="tm-stories-empty"><!--[--><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><div class="tm-stories-card-empty"><div class="tm-stories-card-empty__image"></div><div class="tm-stories-card-empty__title"><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div><div class="tm-stories-card-empty__title-block"></div></div></div><!--]--></div><!----><!--]--></div><!--]--><!----></section><div><div class="placeholder-wrapper"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="tm-placeholder-inset tm-placeholder-salary"><div class="tm-placeholder-inset__header"><div class="tm-placeholder__line tm-placeholder__line_inset-header loads"></div></div><div class="tm-placeholder-salary__body"><div class="tm-placeholder-salary__text"><div class="tm-placeholder__line tm-placeholder__line_salary_average"></div><div class="tm-placeholder-salary__description"><div class="tm-placeholder__line loads"></div><div class="tm-placeholder__line loads"></div><div class="tm-placeholder__line loads"></div><div class="tm-placeholder__line loads"></div></div></div><div class="tm-placeholder-salary__image loads"></div></div><div class="tm-placeholder-inset__footer tm-placeholder-inset__footer_salary"><div class="tm-placeholder__line tm-placeholder__line_inset-footer loads"></div></div></div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----></div></div><!--]--><!----><!--[--><div><div class="placeholder-wrapper"><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><div class="tm-placeholder-promo"><div class="tm-placeholder-promo__header"><div class="tm-placeholder__line tm-placeholder__line_promo-title"></div></div><div class="tm-placeholder-promo__body"><div class="tm-placeholder-promo__posts"><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div><div class="tm-placeholder-promo__post"><div class="tm-placeholder-promo__image"></div><div class="tm-placeholder__line tm-placeholder__line_post-title"></div></div></div><div class="tm-placeholder-promo__dots"><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div><div class="tm-placeholder-promo__dot"></div></div></div></div><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----><!----></div></div><section class="tm-block tm-block tm-block_spacing-top" data-async-called="true"><header class="tm-block__header tm-block__header"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Работа</h2><!--[--><!--]--></div><!----></header><!--[--><div class="tm-block__body tm-block__body"><!--[--><!--[--><div class="tm-vacancies-block__item"><a class="tm-vacancies-block__vacancy-title" href="https://career.habr.com/vacancies/react_razrabotchik" target="_blank">React разработчик</a><div class="tm-vacancies-block__vacancies-count">48
    вакансий</div></div><div class="tm-vacancies-block__item"><a class="tm-vacancies-block__vacancy-title" href="https://career.habr.com/vacancies/programmist_javascript" target="_blank">JavaScript разработчик</a><div class="tm-vacancies-block__vacancies-count">131
    вакансия</div></div><div class="tm-vacancies-block__item"><a class="tm-vacancies-block__vacancy-title" href="https://career.habr.com/vacancies/veb_dizajner" target="_blank">Веб дизайнер</a><div class="tm-vacancies-block__vacancies-count">24
    вакансии</div></div><!--]--><!--]--></div><!--]--><footer class="tm-block__footer"><!--[--><a class="tm-block-extralink" href="https://career.habr.com/catalog">Все вакансии</a><!--]--></footer></section><section class="tm-block tm-block tm-block_spacing-around tm-events-block" data-navigatable tabindex="0" data-async-called="true"><header class="tm-block__header tm-block__header tm-block__header_variant-borderless-large"><div class="tm-block__header-container"><h2 class="tm-block__title tm-block__title">Ближайшие события</h2><!--[--><!--]--></div><!----></header><!--[--><div class="tm-block__body tm-block__body tm-block__body_variant-equal"><!--[--><div class="swiper-container tm-events-widget" style="--swiper-space-between:22px;"><div class="swiper-wrapper"><!--[--><!--[--><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="588" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/588/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png, https://habrastorage.org/getpro/habr/upload_files/f79/1fc/79d/f791fc79d0d9fdda84397ed0c0717764.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>17  февраля   – 24  марта  </span></div></div><a href="/ru/events/588/" class="tm-event-card__title-link"><span>Конкурс «Снежный код» от Хекслета. Три гранта на бесплатное 10-месячное обучение</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#588" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="596" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/596/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png, https://habrastorage.org/getpro/habr/upload_files/b14/cd3/772/b14cd3772bc67698c8fbfd846e23824a.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>20  марта  </span></div></div><a href="/ru/events/596/" class="tm-event-card__title-link"><span>Офлайн-конференция Хабр х K-team: как удерживать таланты в 2025 году</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#596" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="604" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/604/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png, https://habrastorage.org/getpro/habr/upload_files/733/9ef/194/7339ef1945f3ee6906daf89db79829d4.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>20  марта  </span></div></div><a href="/ru/events/604/" class="tm-event-card__title-link"><span>IX HappyWorkForum | Аутентичность и ментальное здоровье персонала</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#604" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="612" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/612/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png, https://habrastorage.org/getpro/habr/upload_files/38f/10d/f4c/38f10df4c7f9d7c5d4610fe426af0ab4.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>20  марта  </span></div></div><a href="/ru/events/612/" class="tm-event-card__title-link"><span>Вебинар «Мастерская бюджета: как управлять затратами на облачные ресурсы»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#612" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="616" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/616/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png, https://habrastorage.org/getpro/habr/upload_files/523/7fb/13a/5237fb13ad7fb6fb483c49691aaec836.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>21  марта  </span></div></div><a href="/ru/events/616/" class="tm-event-card__title-link"><span>Бизнес-конференция «Digital Brand Day 2025: Орбита 2025»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#616" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="608" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/608/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png, https://habrastorage.org/getpro/habr/upload_files/8fd/e04/ddd/8fde04ddd9ba3f6bcd515aa6209f96b7.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>27  марта  </span></div></div><a href="/ru/events/608/" class="tm-event-card__title-link"><span>Вебинар «Контент-маркетинг здорового человека: как привлечь внимание аудитории»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#608" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="606" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/606/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/b99/62a/b24/b9962ab2439c6edc80f96d7f0a847c72.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/b99/62a/b24/b9962ab2439c6edc80f96d7f0a847c72.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/b99/62a/b24/b9962ab2439c6edc80f96d7f0a847c72.png, https://habrastorage.org/getpro/habr/upload_files/b99/62a/b24/b9962ab2439c6edc80f96d7f0a847c72.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>31  марта  </span></div></div><a href="/ru/events/606/" class="tm-event-card__title-link"><span>Серия вебинаров «DevOps Middle: AvitoTech vs ecom.tech»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#606" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="618" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/618/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png, https://habrastorage.org/getpro/habr/upload_files/f76/0f9/a82/f760f9a827b851a5eeca4802c643a91d.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>3  апреля  </span></div></div><a href="/ru/events/618/" class="tm-event-card__title-link"><span>Реалити для разработчиков: узнайте, как строится новое публичное облако MWS</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#618" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="620" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/620/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg, https://habrastorage.org/getpro/habr/upload_files/eba/c37/879/ebac378793b959ebce42f41713e7b67f.jpg 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>3  апреля  </span></div></div><a href="/ru/events/620/" class="tm-event-card__title-link"><span>Открытая встреча «System Analysis Meetup SberHealth»</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#620" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-analytics"><span>Аналитика</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="590" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/590/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png, https://habrastorage.org/getpro/habr/upload_files/31b/e68/295/31be6829578e7934fbc944396eb330b1.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>10  апреля  </span></div></div><a href="/ru/events/590/" class="tm-event-card__title-link"><span>«GoCloud 2025» — масштабная IT-конференция про облака и AI</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Москва</span><span class="tm-event-card__places-separator"> • </span></span><span class="tm-event-card__places-item"><span>Онлайн</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#590" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-admin"><span>Администрирование</span></div><div class="event-category__label event-category__label_type-management"><span>Менеджмент</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="516" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/516/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg, https://habrastorage.org/getpro/habr/upload_files/0e9/3a8/3ec/0e93a83ecea09f806d1df907ddb036a4.jpg 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>25 – 26  апреля  </span></div></div><a href="/ru/events/516/" class="tm-event-card__title-link"><span>IT-конференция Merge Tatarstan 2025</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Казань</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#516" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-marketing"><span>Маркетинг</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><div class="swiper-slide"><!--[--><section class="tm-block tm-block tm-block_spacing-none" id="610" tabindex="-1"><!----><!--[--><div class="tm-event-card tm-event-card_is-widget tm-event-card_responsive"><a href="/ru/events/610/" class=""><img alt class="tm-event-card__image" data-src="https://habrastorage.org/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png" loading="lazy" src="https://habrastorage.org/r/w390/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png" srcset="https://habrastorage.org/r/w390/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png, https://habrastorage.org/getpro/habr/upload_files/652/12d/998/65212d998fb4939d9787bd9c726d2acb.png 2x"></a><!----><div class="tm-event-card__info"><div class="tm-event-card__date"><!----><div class="tm-event-card__day"><span>20 – 22  июня  </span></div></div><a href="/ru/events/610/" class="tm-event-card__title-link"><span>Летняя айти-тусовка Summer Merge</span></a><div class="tm-event-card__places"><div class="tm-event-card__places-list"><!--[--><span class="tm-event-card__places-item"><span>Ульяновская область</span><!----></span><!--]--></div></div></div><div class="tm-event-card__footer tm-event-card__footer_widget"><a href="/ru/events/#610" class="tm-event-card__link">Больше событий в календаре</a><div class="tm-event-card__categories"><!--[--><div class="event-category__label event-category__label_type-development"><span>Разработка</span></div><div class="event-category__label event-category__label_type-other"><span>Другое</span></div><!--]--></div></div></div><!--]--><!----></section><!--]--></div><!--]--><!--]--></div><!----><!--[--><button class="swiper-button-prev"><span class="tm-svg-icon__wrapper swiper-button-icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Влево</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-back"></use></svg></span></button><button class="swiper-button-next"><span class="tm-svg-icon__wrapper swiper-button-icon"><svg class="tm-svg-img tm-svg-icon" height="24" width="24"><title>Вправо</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#arrow-back"></use></svg></span></button><!--]--></div><!--]--></div><!--]--><!----></section><!--]--><!--]--></div><!--]--><!--]--></div></div><!--]--><!--]--></div></div><div class="tm-page__sidebar"><!--[--><!----><!--]--></div></div><!----><!--]--></div></div></main><!----></div><!----><div class="tm-footer"><div class="tm-page-width"><!--[--><div class="tm-footer__container"><div class="tm-footer__title"><a class="tm-svg-icon__wrapper tm-footer__title-link" href="/ru/"><svg class="tm-svg-img tm-svg-icon" height="16" width="16"><title>Хабр</title><use xlink:href="/img/habr-logo-ru.svg#logo"></use></svg></a></div><div class="tm-footer__social"><!--[--><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.facebook.com/habrahabr.ru" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Facebook</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-facebook"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://twitter.com/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Twitter</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-twitter"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://vk.com/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>VK</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-vk"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://telegram.me/habr_com" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Telegram</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-telegram"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://www.youtube.com/channel/UCd_sTwKqVrweTt4oAKY5y4w" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Youtube</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-youtube"></use></svg></a><a class="tm-svg-icon__wrapper tm-social-icons__icon" href="https://dzen.ru/habr" rel="nofollow noopener noreferrer" target="_blank"><svg class="tm-svg-img tm-svg-icon" height="36" width="36"><title>Яндекс Дзен</title><use xlink:href="/img/new-social-icons-sprite.svg#social-logo-dzen"></use></svg></a><!--]--></div><!--teleport start--><!--teleport end--><button class="tm-footer__link"><svg class="tm-svg-img tm-footer__icon" height="16" width="16"><title>Язык</title><use xlink:href="/img/megazord-v28.371b7fa3..svg#lang"></use></svg> Настройка языка</button><a href="/ru/feedback/" class="tm-footer__link">Техническая поддержка</a><div class="tm-footer-copyright"><span class="tm-copyright"><span class="tm-copyright__years">© 2006–2025, </span><span class="tm-copyright__name"><a class="tm-copyright__link" href="https://company.habr.com/" rel="noopener" target="_blank">Habr</a></span></span></div></div><!--]--></div></div><!----><!--]--></div><!----></div><script>window.__INITIAL_STATE__={"adblock":{"hasAcceptableAdsFilter":false,"hasAdblock":false},"articlesList":{"articlesList":{"555744":{"id":"555744","timePublished":"2021-05-04T16:37:44+00:00","isCorporative":false,"lang":"ru","titleHtml":"Практика по Котлину: Создание веб приложений на React и Kotlin\u002FJS","leadData":{"textHtml":"\u003Cp\u003E\u003Cem\u003EОт переводчика\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EПривет! Про \u003Cstrong\u003EKotlin\u003C\u002Fstrong\u003E есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ (\u003Cstrong\u003EJVM\u003C\u002Fstrong\u003E, \u003Cstrong\u003EJS\u003C\u002Fstrong\u003E, \u003Cstrong\u003ENative\u003C\u002Fstrong\u003E), а также умеет работать с библиотеками для этих платформ, написанных на других языках. Такая поддержка &quot;мультиплатформенности&quot; позволяет не только писать всевозможные проекты на одном языке в единой форме, но и переиспользовать код при написании одного проекта под разные платформы.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EВ этой статье я перевожу \u003Ca href=\"https:\u002F\u002Fplay.kotlinlang.org\u002Fhands-on\u002FBuilding%20Web%20Applications%20with%20React%20and%20Kotlin%20JS\" rel=\"nofollow noopener noreferrer\"\u003Eофициальный туториал Kotlin Hands-On\u003C\u002Fa\u003E о создании веб сайтов на Котлине. Мы рассмотрим многие аспекты программирования на Kotlin\u002FJS и поймем, как работать не только с чистым DOM. В основном будем говорить о \u003Ca href=\"https:\u002F\u002Freactjs.org\u002F\" rel=\"nofollow noopener noreferrer\"\u003EReact JS\u003C\u002Fa\u003E, но также коснемся системы сборки \u003Cstrong\u003EGradle\u003C\u002Fstrong\u003E, использования зависимостей из \u003Cstrong\u003ENPM\u003C\u002Fstrong\u003E, обращения к \u003Cstrong\u003EREST API\u003C\u002Fstrong\u003E, деплоя на \u003Cstrong\u003EHeroku\u003C\u002Fstrong\u003E, и в итоге сделаем \u003Cem\u003Eприложение-видеоплеер\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003EТекст ориентирован на тех, кто немного знает Котлин и не знает или почти не знает Реакт. Если вы более опытны по этим вопросам, то части туториала могут показаться вам чрезмерно разжеванными.\u003C\u002Fp\u003E\u003Cbr\u003E\r\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe82\u002F357\u002Fada\u002Fe82357ada36198277e49b1ad14a830bc.png\" alt=\"kotlin-react\"\u003E\u003C\u002Fp\u003E","imageUrl":null,"buttonTextHtml":"Читать дальше &rarr;","image":null},"editorVersion":"1.0","postType":"article","postLabels":[{"type":"translation","typeOf":"system","title":"Перевод","data":{"originalAuthorName":"JetBrains – Kotlin Team","originalUrl":"https:\u002F\u002Fplay.kotlinlang.org\u002Fhands-on\u002FBuilding%2520Web%2520Applications%2520with%2520React%2520and%2520Kotlin%2520JS\u002F01_Introduction"}}],"author":{"id":"1460524","alias":"SerVB","fullname":null,"avatarUrl":null,"speciality":null,"scoreStats":{"score":6,"votesCount":8},"rating":0,"relatedData":null,"contacts":[],"authorContacts":[],"paymentDetails":{"paymentYandexMoney":null,"paymentPayPalMe":null,"paymentWebmoney":null},"donationsMethod":null,"isInBlacklist":null,"careerProfile":null},"statistics":{"commentsCount":7,"favoritesCount":78,"readingCount":28874,"score":6,"votesCount":8,"votesCountPlus":7,"votesCountMinus":1},"hubs":[{"id":"357","alias":"javascript","type":"collective","title":"JavaScript","titleHtml":"JavaScript","isProfiled":true,"relatedData":null},{"id":"19441","alias":"kotlin","type":"collective","title":"Kotlin","titleHtml":"Kotlin","isProfiled":true,"relatedData":null},{"id":"19327","alias":"reactjs","type":"collective","title":"ReactJS","titleHtml":"ReactJS","isProfiled":true,"relatedData":null},{"id":"47","alias":"web_design","type":"collective","title":"Веб-дизайн","titleHtml":"Веб-дизайн","isProfiled":true,"relatedData":null},{"id":"91","alias":"webdev","type":"collective","title":"Веб-разработка","titleHtml":"Веб-разработка","isProfiled":true,"relatedData":null}],"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка"},{"id":"2","alias":"design","title":"Дизайн","titleHtml":"Дизайн"}],"relatedData":{"vote":null,"unreadCommentsCount":0,"bookmarked":false,"canComment":false,"canEdit":false,"canViewVotes":false,"votePlus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":true,"isPublicationLimitEnough":false},"voteMinus":{"canVote":false,"isChargeEnough":false,"isKarmaEnough":false,"isVotingOver":true,"isPublicationLimitEnough":false},"canModerateComments":false,"trackerSubscribed":false,"emailSubscribed":false},"textHtml":"\u003Cdiv xmlns=\"http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxhtml\"\u003E\u003Cp\u003E\u003Cem\u003EОт переводчика\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПривет! Про \u003Cstrong\u003EKotlin\u003C\u002Fstrong\u003E есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ (\u003Cstrong\u003EJVM\u003C\u002Fstrong\u003E, \u003Cstrong\u003EJS\u003C\u002Fstrong\u003E, \u003Cstrong\u003ENative\u003C\u002Fstrong\u003E), а также умеет работать с библиотеками для этих платформ, написанных на других языках. Такая поддержка \"мультиплатформенности\" позволяет не только писать всевозможные проекты на одном языке в единой форме, но и переиспользовать код при написании одного проекта под разные платформы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ этой статье я перевожу \u003Ca href=\"https:\u002F\u002Fplay.kotlinlang.org\u002Fhands-on\u002FBuilding%20Web%20Applications%20with%20React%20and%20Kotlin%20JS\" rel=\"nofollow noopener noreferrer\"\u003Eофициальный туториал Kotlin Hands-On\u003C\u002Fa\u003E о создании веб сайтов на Котлине. Мы рассмотрим многие аспекты программирования на Kotlin\u002FJS и поймем, как работать не только с чистым DOM. В основном будем говорить о \u003Ca href=\"https:\u002F\u002Freactjs.org\u002F\" rel=\"nofollow noopener noreferrer\"\u003EReact JS\u003C\u002Fa\u003E, но также коснемся системы сборки \u003Cstrong\u003EGradle\u003C\u002Fstrong\u003E, использования зависимостей из \u003Cstrong\u003ENPM\u003C\u002Fstrong\u003E, обращения к \u003Cstrong\u003EREST API\u003C\u002Fstrong\u003E, деплоя на \u003Cstrong\u003EHeroku\u003C\u002Fstrong\u003E, и в итоге сделаем \u003Cem\u003Eприложение-видеоплеер\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТекст ориентирован на тех, кто немного знает Котлин и не знает или почти не знает Реакт. Если вы более опытны по этим вопросам, то части туториала могут показаться вам чрезмерно разжеванными.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe82\u002F357\u002Fada\u002Fe82357ada36198277e49b1ad14a830bc.png\" alt=\"kotlin-react\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe82\u002F357\u002Fada\u002Fe82357ada36198277e49b1ad14a830bc.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Ca name=\"habracut\"\u003E\u003C\u002Fa\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНадеюсь, статья удовлетворит \u003Ca href=\"https:\u002F\u002Fhabr.com\u002Fru\u002Fcompany\u002Fproductsense\u002Fblog\u002F526238\u002F#comment_22257922\"\u003Eпусть даже непопулярные запросы\u003C\u002Fa\u003E на материалы о Котлине на русском.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПредлагать правки в эту статью лучше всего \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FSerVB\u002Fkotlin-hands-on-ru\u002Fedit\u002Fmaster\u002Fhands-on\u002FBuilding%20Web%20Applications%20with%20React%20and%20Kotlin%20JS.md\" rel=\"nofollow noopener noreferrer\"\u003Eна ГитХабе\u003C\u002Fa\u003E. Текущий перевод построен на версии оригинального туториала, актуальной на 09.04.2021.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"soderzhanie\"\u003EСодержание\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep1shag-1-vvedeniea\"\u003EВведение\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep2shag-2-nastroykaa\"\u003EНастройка\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep3shag-3-pervaya-stranica-na-reakte--statichnayaa\"\u003EПервая страница на Реакте – статичная\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep4shag-4-react--o-reakciyah-nash-pervyy-komponenta\"\u003EReact – о реакциях. Наш первый компонент\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep5shag-5-rabotaem-sovmestno-kompoziciya-komponentova\"\u003EРаботаем совместно. Композиция компонентов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep6shag-6-bolshe-komponentova\"\u003EБольше компонентов!\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep7shag-7-ispolzovanie-npm-paketova\"\u003EИспользование NPM пакетов\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep8shag-8-ispolzuem-vneshnee-rest-apia\"\u003EИспользуем внешнее REST API\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep9shag-9-deploim-v-prodakshen-i-v-oblakoa\"\u003EДеплоим в продакшен и в облако\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep10shag-10-v-dopolnenie-sovremennyy-reakt-s-hukamia\"\u003EВ дополнение: современный Реакт с хуками\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"#a-namestep11shag-11-chto-dalshea\"\u003EЧто дальше?\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep1shag-1-vvedeniea\"\u003EШаг 1. Введение\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа этой практике мы рассмотрим, как использовать Kotlin\u002FJS вместе с популярным фреймворком \u003Ca href=\"https:\u002F\u002Freactjs.org\u002F\" rel=\"nofollow noopener noreferrer\"\u003EReact\u003C\u002Fa\u003E для создания красивых и поддерживаемых браузерных приложений. React позволяет создавать веб приложения современно и структурировано, фокусируясь на переиспользовании компонентов и на особом способе управления состоянием приложения. Он имеет большую экосистему материалов и компонентов, созданную сообществом.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИспользование Котлина для написания приложений на React позволяет опираться на наши знания о парадигмах, синтаксисе и инструментах этого языка при создании фронт-энд приложений для современных браузеров. А еще использовать котлиновские библиотеки одновременно с возможностями платформы и экосистемы JavaScript.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа этой практике мы научимся создавать приложение на Kotlin\u002FJS и React, используя Gradle плагин \u003Ccode\u003Eorg.jetbrains.kotlin.js\u003C\u002Fcode\u003E. Мы решим задачи, обычно возникающие при создании типичного простого React приложения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы узнаем, как \u003Cem\u003Eпредметно-ориентированные языки\u003C\u002Fem\u003E (\u003Cem\u003EDSL\u003C\u002Fem\u003E) помогают выражать идеи кратким и единообразным способом без жертв читаемости, давая возможность написать полноценное приложение полностью на Котлине. Также мы покажем, как использовать уже сделанные сообществом компоненты и библиотеки, и как опубликовать получившееся приложение.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПредполагается, что у вас уже есть базовое понимание Котлина, и \u003Cem\u003Eсовсем поверхностное\u003C\u002Fem\u003E знание HTML и CSS. Базовое знание идей Реакта будет полезным для понимания примеров кода, но не обязательно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"chto-imenno-my-sozdadim\"\u003EЧто именно мы создадим\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕжегодное событие \u003Ca href=\"https:\u002F\u002Fkotlinconf.com\u002F\" rel=\"nofollow noopener noreferrer\"\u003EKotlinConf\u003C\u002Fa\u003E стоит посетить, если вы хотите узнать больше о Котлине и пообщаться с сообществом. KotlinConf 2018 предлагал огромное количество информации в виде мастер-классов и лекций и насчитывал 1300 участников. Доклады публично доступны на YouTube, и поклонникам Котлина было бы полезно \u003Cstrong\u003Eувидеть\u003C\u002Fstrong\u003E перечень докладов на одной странице и \u003Cstrong\u003Eпомечать\u003C\u002Fstrong\u003E их как \u003Cem\u003Eпросмотренные\u003C\u002Fem\u003E – идеально для погружения в Котлин \"запоем\". На этой практике мы как раз создадим такое приложение – \u003Cem\u003EKotlinConf Explorer\u003C\u002Fem\u003E (см. скриншот ниже).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe98\u002F63c\u002F4b8\u002Fe9863c4b8f99d4ae60691fbf15bfe1a8.png\" alt=\"Результат\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe98\u002F63c\u002F4b8\u002Fe9863c4b8f99d4ae60691fbf15bfe1a8.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИсходный код финального приложения, как и промежуточные результаты, можно найти \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E на GitHub. Результат каждого шага доступен в соответствующей ветке, ссылки на которые мы дополнительно дублируем в конце каждого параграфа.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНачнем с настройки среды разработки и установки инструментов, которые помогут нам в работе.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep2shag-2-nastroykaa\"\u003EШаг 2. Настройка\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"prerekvizity\"\u003EПререквизиты\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы начать, давайте убедимся, что у вас установлена актуальная среда разработки. Вот все, что нам нужно сейчас – это IntelliJ IDEA (версии \u003Ccode\u003E2020.3\u003C\u002Fcode\u003E или новее, достаточно бесплатной Community Edition) с плагином Котлин (\u003Ccode\u003E1.4.30\u003C\u002Fcode\u003E или новее) – скачать можно \u003Ca href=\"https:\u002F\u002Fwww.jetbrains.com\u002Fidea\u002Fdownload\u002F\" rel=\"nofollow noopener noreferrer\"\u003Eпо ссылке\u003C\u002Fa\u003E. Выберите установочный файл, соответствующий вашей ОС (поддерживаются Windows, MacOS и Linux).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"sozdaem-proekt\"\u003EСоздаем проект\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля этой практики мы подготовили стартовый шаблон проекта, включающий все настройки и зависимости.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСклонируйте \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\" rel=\"nofollow noopener noreferrer\"\u003Eэтот GitHub репозиторий\u003C\u002Fa\u003E и откройте его с помощью IntelliJ IDEA (например, с помощью \u003Cstrong\u003EFile | New | Project from Version Control...\u003C\u002Fstrong\u003E или \u003Cstrong\u003EGit | Clone...\u003C\u002Fstrong\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЭтот шаблон содержит простейший Kotlin\u002FJS Gradle проект, на основе которого можно делать что-то свое. Так как в Gradle конфигурации шаблона уже прописаны все необходимые для практики зависимости, \u003Cstrong\u003Eвам не придется изменять ее\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ любом случае полезно понимать, какие артефакты используются для приложения, так что давайте посмотрим повнимательнее на шаблонные зависимости и конфигурации.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПримечание от переводчика\u003C\u002Fstrong\u003E: конечно, для будущих проектов можно начинать как с шаблона, так и с пустого Gradle проекта, добавляя только нужные зависимости – для этого как раз и предстоит с ними разобраться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"zavisimosti-i-zadachi-gradle\"\u003EЗависимости и задачи Gradle\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа практике мы будем использовать React, некоторые другие внешние зависимости, а еще котлиновские библиотеки. Чтобы не тратить время на импортирование изменений Gradle скриптов на каждом шаге, мы добавляем все зависимости в самом начале.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля начала давайте убедимся, что внутри файла \u003Ccode\u003Ebuild.gradle.kts\u003C\u002Fcode\u003E есть блок \u003Ccode\u003Erepositories\u003C\u002Fcode\u003E. Таким образом объявляются источники зависимостей.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБлок зависимостей \u003Ccode\u003Edependencies\u003C\u002Fcode\u003E содержит все нужные для практики внешние библиотеки:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Edependencies {\n    \u002F\u002F React, React DOM + Wrappers (шаг 3)\n    implementation(\"org.jetbrains:kotlin-react:17.0.1-pre.148-kotlin-1.4.21\")\n    implementation(\"org.jetbrains:kotlin-react-dom:17.0.1-pre.148-kotlin-1.4.21\")\n    implementation(npm(\"react\", \"17.0.1\"))\n    implementation(npm(\"react-dom\", \"17.0.1\"))\n\n    \u002F\u002F Kotlin Styled (шаг 3)\n    implementation(\"org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21\")\n    implementation(npm(\"styled-components\", \"~5.2.1\"))\n\n    \u002F\u002F Video Player (шаг 7)\n    implementation(npm(\"react-youtube-lite\", \"1.0.1\"))\n\n    \u002F\u002F Share Buttons (шаг 7)\n    implementation(npm(\"react-share\", \"~4.2.1\"))\n\n    \u002F\u002F Coroutines (шаг 8)\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.4.3\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли отредактировать файл, IDEA автоматически предложит импортировать изменения Gradle скриптов. Импорт также можно инициировать в любой момент, нажав на кнопку \u003Cstrong\u003E Reimport All Gradle Projects\u003C\u002Fstrong\u003E в тул-окне Gradle (сбоку справа).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"html-stranica\"\u003EHTML страница\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТак как мы не можем вызывать JavaScript сам по себе, мы должны написать связанную с нашим JS файлом HTML страницу, и именно ее открывать в браузере. В проекте уже есть файл \u003Ccode\u003Esrc\u002Fmain\u002Fresources\u002Findex.html\u003C\u002Fcode\u003E со следующим содержимым:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"html\"\u003E&lt;!doctype html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Hello, Kotlin\u002FJS!&lt;\u002Ftitle&gt;\n&lt;\u002Fhead&gt;\n&lt;body&gt;\n    &lt;div id=\"root\"&gt;&lt;\u002Fdiv&gt;\n    &lt;script src=\"confexplorer.js\"&gt;&lt;\u002Fscript&gt;\n&lt;\u002Fbody&gt;\n&lt;\u002Fhtml&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБлагодаря Kotlin\u002FJS Gradle плагину, весь наш код и зависимости будут объединены (\"забандлены\") в единый JavaScript артефакт, носящий с проектом одно имя. Соответственно мы добавили в HTML файл вызов скрипта \u003Ccode\u003Econfexplorer.js\u003C\u002Fcode\u003E (заметьте, что если бы проект был назван, например, как \u003Ccode\u003EfollowingAlong\u003C\u002Fcode\u003E, имя скрипта было бы \u003Ccode\u003EfollowingAlong.js\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВыполняя обыденную \u003Ca href=\"https:\u002F\u002Ffaqs.skillcrush.com\u002Farticle\u002F176-where-should-js-script-tags-be-linked-in-html-documents\" rel=\"nofollow noopener noreferrer\"\u003Eконвенцию JavaScript\u003C\u002Fa\u003E, мы сначала позволяем загрузить контент нашей страницы (включая элемент \u003Ccode\u003E#root\u003C\u002Fcode\u003E) и только в конце загружаем скрипт. Таким образом, страница будет загружена к моменту выполнения нашего скрипта, и мы сможем сразу же к ней обращаться.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПримечание от переводчика\u003C\u002Fstrong\u003E: если у вас уже есть опыт с HTML, возможно, вы привыкли использовать свойство \u003Ccode\u003EonLoad\u003C\u002Fcode\u003E у элемента \u003Ccode\u003Ebody\u003C\u002Fcode\u003E для решения этой же проблемы. Однако при использовании Kotlin\u002FJS намного проще именно просто объявлять скрипт в конце \u003Ccode\u003Ebody\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПеред написанием \"Hello, World\" с настоящей разметкой, начнем с простейшего визуального примера – страницы, залитой сплошным цветом. Этот пример поможет понять, то что наш код действительно доходит до браузера и выполняется без ошибок. Для кода у нас есть файл \u003Ccode\u003Esrc\u002Fmain\u002Fkotlin\u002FMain.kt\u003C\u002Fcode\u003E с таким содержимым:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport kotlinx.browser.document\n\nfun main() {\n    document.bgColor = \"red\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь нам нужно скомпилировать и запустить наш код.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"zapusk-servera-dlya-razrabotki\"\u003EЗапуск сервера для разработки\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EKotlin\u002FJS Gradle плагин из коробки поддерживает \u003Cstrong\u003Ewebpack-dev-server\u003C\u002Fstrong\u003E, что позволяет нам хостить приложение прямо с помощью IDE и не настраивать веб сервер отдельно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы можем запустить сервер, вызвав задачу \u003Ccode\u003Erun\u003C\u002Fcode\u003E или \u003Ccode\u003EbrowserDevelopmentRun\u003C\u002Fcode\u003E из тул-окна Gradle. Она может быть либо в группе \u003Ccode\u003Eother\u003C\u002Fcode\u003E (как на скриншоте), либо в \u003Ccode\u003Ekotlin browser\u003C\u002Fcode\u003E:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F897\u002F290\u002F973\u002F897290973b762d0318e9a62b3971a221.png\" alt=\"Задача для запуска сервера\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F897\u002F290\u002F973\u002F897290973b762d0318e9a62b3971a221.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли хочется запускать не из IDE, а из терминала, то можно выполнить \u003Ccode\u003E.\u002Fgradlew run\u003C\u002Fcode\u003E (\u003Cem\u003Eв Windows\u003C\u002Fem\u003E Gradle команды выглядят немного по-другому: \u003Ccode\u003E.\\gradlew.bat run\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНаш проект скомпилируется и забандлится, и через несколько секунд должно открыться окно браузера с пустой красной страницей, означающей, что наш код заработал успешно:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fdc2\u002F12f\u002F22f\u002Fdc212f22f7b4bd36e6d18600f87ef77a.png\" alt=\"Красная страница\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fdc2\u002F12f\u002F22f\u002Fdc212f22f7b4bd36e6d18600f87ef77a.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"vklyuchenie-goryachey-perezagruzki-hot-reload-aka-nepreryvnogo-rezhima\"\u003EВключение горячей перезагрузки (hot reload) a.k.a. непрерывного режима\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВместо того чтобы вручную вызывать компиляцию проекта и обновление страницы в браузере для тестирования изменений в коде, мы можем использовать \u003Cem\u003Eрежим непрерывной компиляции\u003C\u002Fem\u003E – Kotlin\u002FJS поддерживает ее. Для этого нам потребуется немного модифицировать вызов \u003Ccode\u003Erun\u003C\u002Fcode\u003E задачи Gradle.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНеобходимо также убедиться, что запущенный ранее веб сервер остановлен (нажмите в IDE на красный квадрат – \u003Cstrong\u003EStop\u003C\u002Fstrong\u003E; если работаете в терминале – нажмите \u003Ccode\u003ECtrl+C\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли вы запускаете задачу с помощью IDEA, нужно добавить флаг в конфигурацию запуска. Эту конфигурацию IDEA создала, когда мы впервые запустили Gradle задачу, а теперь нам нужно ее отредактировать:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F81c\u002Fa95\u002F32c\u002F81ca9532c243740abf29334207164d52.png\" alt=\"Открытие редактирования\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F81c\u002Fa95\u002F32c\u002F81ca9532c243740abf29334207164d52.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ открывшемся окне \u003Cstrong\u003ERun\u002FDebug Configurations\u003C\u002Fstrong\u003E надо добавить флаг \u003Ccode\u003E--continuous\u003C\u002Fcode\u003E в аргументы конфигурации запуска:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F275\u002F194\u002F45d\u002F27519445d08e39e965416a2db3c07892.png\" alt=\"Добавление аргумента\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F275\u002F194\u002F45d\u002F27519445d08e39e965416a2db3c07892.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПосле применения изменений мы можем использовать зеленую кнопку \u003Cstrong\u003ERun\u003C\u002Fstrong\u003E (\u003Ccode\u003E|&gt;\u003C\u002Fcode\u003E) для запуска сервера.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли вы запускаете сервер из терминала, это можно сделать примерно так: \u003Ccode\u003E.\u002Fgradlew run --continuous\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля тестирования только что активированной функции предлагаем изменить цвет страницы, когда Gradle задача выполняется. Например, можно изменить на синий:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Edocument.bgColor = \"blue\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли сохранить файл, через пару секунд проект должен автоматически перекомпилироваться, а страница браузера – перезагрузиться и окраситься в новый цвет.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВо время разработки можно оставлять сервер запущенным. Он будет следить за изменениями в коде и автоматически компилировать код и перезагружать страницу. Если хотите, можете поиграться с кодом на этой начальной стадии.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"primechanie-ot-perevodchika-naschet-nepreryvnoy-kompilyacii\"\u003EПримечание от переводчика насчет непрерывной компиляции\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЯ пробовал этот режим, и, если честно, он мне показался неудобным. Во-первых, перезагрузка страницы иногда бывает нежелательна, особенно если там были какие-то несохраненные данные. Во-вторых, я не всегда понимаю, успели ли уже перекомпилироваться код и перезагрузиться страница. В-третьих, этот режим почему-то не всегда видит изменения, и доходит до того, что приходится перезапускать Gradle задачу, то есть сама суть режима нарушается – все еще приходится делать что-то руками.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ итоге я уже года два, с момента начала моего использования Kotlin\u002FJS, вручную запускаю компиляцию кода и перезагрузку страницы. Более того, я вообще не использую веб сервер при разработке: я просто открываю в браузере локальный HTML файл. Для компиляции я использую задачу \u003Ccode\u003EbrowserDevelopmentWebpack\u003C\u002Fcode\u003E, после этого построенные файлы становятся доступны в папке \u003Ccode\u003Ebuild\u002Fdistributions\u003C\u002Fcode\u003E или в \u003Ccode\u003Ebuild\u002FdevelopmentExecutable\u003C\u002Fcode\u003E. Оттуда я переношу в браузер файл \u003Ccode\u003Eindex.html\u003C\u002Fcode\u003E, и все работает довольно безотказно и предельно логично.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"na-start-vnimanie\"\u003EНа старт, внимание...\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы настроили пустой Kotlin\u002FJS проект, который может развиться во все что угодно. Время начинать верстать!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Emaster\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fmaster\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep3shag-3-pervaya-stranica-na-reakte--statichnayaa\"\u003EШаг 3. Первая страница на Реакте – статичная\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ мире программирования принято начинать обучение с \u003Cem\u003EHello, World\u003C\u002Fem\u003E. Так давайте изменим нашу одноцветную страницу в соответствии с традициями.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПоменяйте код в файле \u003Ccode\u003Esrc\u002Fmain\u002Fkotlin\u002FMain.kt\u003C\u002Fcode\u003E на примерно следующий:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport react.dom.*\nimport kotlinx.browser.document\n\nfun main() {\n    render(document.getElementById(\"root\")) {\n        h1 {\n            +\"Hello, React+Kotlin\u002FJS!\"\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПосле сборки изменившегося проекта в браузере можно увидеть магию:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fada\u002F0a2\u002F550\u002Fada0a25506506187b003da6597154be9.png\" alt=\"hello-world\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fada\u002F0a2\u002F550\u002Fada0a25506506187b003da6597154be9.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EУра, вы только что написали свой первый веб сайт на чистом Котлине с Реактом! Давайте попробуем понять, как работает этот код. Функция \u003Ccode\u003Erender\u003C\u002Fcode\u003E говорит библиотеке \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\u002Ftree\u002Fmaster\u002Fkotlin-react-dom\" rel=\"nofollow noopener noreferrer\"\u003Ekotlin-react-dom\u003C\u002Fa\u003E отрендерить наш \u003Cem\u003Eкомпонент\u003C\u002Fem\u003E (поговорим о компонентах чуть позже) внутрь элемента на странице. Если помните, в \u003Ccode\u003Esrc\u002Fmain\u002Fresources\u002Findex.html\u003C\u002Fcode\u003E есть элемент с ID \u003Ccode\u003Eroot\u003C\u002Fcode\u003E, как раз туда мы и рендерим. Содержимое рендеринга сейчас довольно простое – единственный заголовок первого уровня. Для объявления содержимого, то есть HTML элементов, используется типобезопасный DSL.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"tipobezopasnyy-html\"\u003EТипобезопасный HTML\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБиблиотека \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\u002Fblob\u002Fmaster\u002Fkotlin-react\u002FREADME.md\" rel=\"nofollow noopener noreferrer\"\u003Ekotlin-react\u003C\u002Fa\u003E использует котлиновскую возможность написания DSL, таким образом заменяя синтаксис разметки HTML на нечто более легкочитаемое. Возможно, такой DSL вам покажется и легче в написании.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКод на Котлине дает нам все преимущества статически типизированного языка, от \u003Cem\u003Eпроверки типов\u003C\u002Fem\u003E до \u003Cem\u003Eавтодополнения\u003C\u002Fem\u003E. Скорее всего, из-за этого вы проведете \u003Cem\u003Eменьше времени в отладке\u003C\u002Fem\u003E, охотясь за опечатками в именах атрибутов, и у вас появится \u003Cem\u003Eбольше времени на создание\u003C\u002Fem\u003E отточенного приложения!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EО знаке \u003Ccode\u003E+\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕдинственная довольно неочевидная на первый взгляд вещь в котлиновском листинге выше – знак \u003Ccode\u003E+\u003C\u002Fcode\u003E перед строковым литералом. Поясним. \u003Ccode\u003Eh1\u003C\u002Fcode\u003E – это функция, принимающая лямбду как параметр. Когда мы пишем \u003Ccode\u003E+\u003C\u002Fcode\u003E, мы на самом деле вызываем \u003Ca href=\"https:\u002F\u002Fkotlinlang.org\u002Fdocs\u002Freference\u002Foperator-overloading.html\" rel=\"nofollow noopener noreferrer\"\u003Eперегруженный оператор\u003C\u002Fa\u003E \u003Ccode\u003EunaryPlus\u003C\u002Fcode\u003E, которая добавляет строку в окружающий HTML элемент.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПроще говоря, операцию \u003Ccode\u003E+\u003C\u002Fcode\u003E можно понимать как инструкцию \"добавь мою строчку текста внутрь этого элемента\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"perepisyvaem-klassicheskiy-html\"\u003EПереписываем классический HTML\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКогда у нас есть мысли о том, как будет выглядеть наш сайт, мы можем сразу перевести наш (мысленный) набросок в котлиновское объявление HTML. Если вы уже привыкли писать обычный HTML, у вас не должно возникнуть проблем и с котлиновским. Сейчас мы хотим создать разметку, которую можно записать примерно так на чистом HTML:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"html\"\u003E&lt;h1&gt;KotlinConf Explorer&lt;\u002Fh1&gt;\n&lt;div&gt;\n    &lt;h3&gt;Videos to watch&lt;\u002Fh3&gt;\n    &lt;p&gt;John Doe: Building and breaking things&lt;\u002Fp&gt;\n    &lt;p&gt;Jane Smith: The development process&lt;\u002Fp&gt;\n    &lt;p&gt;Matt Miller: The Web 7.0&lt;\u002Fp&gt;\n\n    &lt;h3&gt;Videos watched&lt;\u002Fh3&gt;\n    &lt;p&gt;Tom Jerry: Mouseless development&lt;\u002Fp&gt;\n&lt;\u002Fdiv&gt;\n&lt;div&gt;\n    &lt;h3&gt;John Doe: Building and breaking things&lt;\u002Fh3&gt;\n    &lt;img src=\"https:\u002F\u002Fvia.placeholder.com\u002F640x360.png?text=Video+Player+Placeholder\"&gt;\n&lt;\u002Fdiv&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте переведем этот код в Kotlin DSL. Конверсия довольно прямолинейна. Если хотите поупражняться, можете попробовать переписать самостоятельно, \u003Cstrong\u003Eне подглядывая\u003C\u002Fstrong\u003E в листинг ниже:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eh1 {\n    +\"KotlinConf Explorer\"\n}\ndiv {\n    h3 {\n        +\"Videos to watch\"\n    }\n    p {\n        +\"John Doe: Building and breaking things\"\n    }\n    p {\n        +\"Jane Smith: The development process\"\n    }\n    p {\n        +\"Matt Miller: The Web 7.0\"\n    }\n\n    h3 {\n        +\"Videos watched\"\n    }\n    p {\n        +\"Tom Jerry: Mouseless development\"\n    }\n}\ndiv {\n    h3 {\n        +\"John Doe: Building and breaking things\"\n    }\n    img {\n       attrs {\n           src = \"https:\u002F\u002Fvia.placeholder.com\u002F640x360.png?text=Video+Player+Placeholder\"\n       }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПерепишите или скопируйте этот листинг внутрь вызова \u003Ccode\u003Erender\u003C\u002Fcode\u003E. Если IntelliJ IDEA ругается на отсутствующие импорты, просто вызовите соответствующие быстрые исправления (quick-fixes) с помощью \u003Ccode\u003EAlt+Enter\u003C\u002Fcode\u003E. Когда обновленный файл будет скомпилирован и страница в браузере перезагружена, вас будет приветствовать следующий экран:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Faff\u002F20b\u002F47c\u002Faff20b47c153c8002fea293f13976a4b.png\" alt=\"kotlinconf-placeholder\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Faff\u002F20b\u002F47c\u002Faff20b47c153c8002fea293f13976a4b.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"ispolzovanie-kotlinovskih-yazykovyh-konstrukciy-v-razmetke\"\u003EИспользование котлиновских языковых конструкций в разметке\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНаписание HTML на DSL на самом деле имеет намного больше преимуществ по сравнению с чистым HTML. Основное отличие – это то что мы можем жонглировать контентом страницы, используя \u003Cstrong\u003Eуже знакомые нам конструкции языка\u003C\u002Fstrong\u003E. Условные переходы, циклы, коллекции, подстановка внутри строк – все это будет работать в HTML DSL так же, как и обычно в Котлине.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте теперь вместо захардкоживания списка видео объявим переменную-список и будем ее использовать в разметке. Создадим класс \u003Ccode\u003EKotlinVideo\u003C\u002Fcode\u003E, чтобы хранить свойства видео (класс можно создать либо в \u003Ccode\u003EMain.kt\u003C\u002Fcode\u003E, либо в другом файле – как хотите), а также \u003Ccode\u003Eexternal\u003C\u002Fcode\u003E интерфейс – о нем поговорим позже, когда будем получать данные из внешнего API:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface Video {\n    val id: Int\n    val title: String\n    val speaker: String\n    val videoUrl: String\n}\n\ndata class KotlinVideo(\n    override val id: Int,\n    override val title: String,\n    override val speaker: String,\n    override val videoUrl: String\n) : Video\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПотом объявим два списка: для непросмотренных и просмотренных видео. Пока что можно сделать это в файле \u003Ccode\u003EMain.kt\u003C\u002Fcode\u003E на верхнем уровне:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval unwatchedVideos = listOf(\n    KotlinVideo(1, \"Building and breaking things\", \"John Doe\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\"),\n    KotlinVideo(2, \"The development process\", \"Jane Smith\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\"),\n    KotlinVideo(3, \"The Web 7.0\", \"Matt Miller\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\")\n)\n\nval watchedVideos = listOf(\n    KotlinVideo(4, \"Mouseless development\", \"Tom Jerry\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\")\n)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы использовать эти значения в HTML, нам не нужно знать ничего, кроме базового синтаксиса Котлина! Мы можем написать код для прохода по коллекции и добавлять HTML элемент для каждого элемента коллекции. То есть вместо трех тегов \u003Ccode\u003Ep\u003C\u002Fcode\u003E для непросмотренных видео, мы можем написать примерно такое:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Efor (video in unwatchedVideos) {\n    p {\n        +\"${video.speaker}: ${video.title}\"\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EАналогично можно изменить разметку чуть ниже для использования списка \u003Ccode\u003EwatchedVideos\u003C\u002Fcode\u003E. После перекомпиляции проекта и обновления страницы мы убедимся, что страница эквивалентна предыдущему варианту. Если хотите удостовериться, что циклы на самом деле работают, попробуйте поэкспериментировать и, например, добавить новые элементы в списки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"tipobezopasnyy-css\"\u003EТипобезопасный CSS\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМожно сказать, мы уже продвинулись в проекте, но не время делать паузу: к сожалению, наше приложение до сих пор выглядит \u003Cem\u003Eнесколько безвкусно\u003C\u002Fem\u003E и \u003Cem\u003Eне сильно привлекательно\u003C\u002Fem\u003E. Для исправления ситуации мы могли бы подключить какой-нибудь \u003Ccode\u003E.css\u003C\u002Fcode\u003E файл в наш файл \u003Ccode\u003Eindex.html\u003C\u002Fcode\u003E, но давайте лучше воспользуемся случаем, чтобы поиграться с Kotlin DSL опять – на этот раз с CSS.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБиблиотека \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\u002Ftree\u002Fmaster\u002Fkotlin-styled\" rel=\"nofollow noopener noreferrer\"\u003Ekotlin-styled\u003C\u002Fa\u003E предоставляет чудесные типобезопасные обертки для \u003Ca href=\"https:\u002F\u002Fwww.styled-components.com\u002F\" rel=\"nofollow noopener noreferrer\"\u003Estyled-components\u003C\u002Fa\u003E и позволяет нам быстро и безопасно объявлять стили как \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\u002Fblob\u002Fmaster\u002Fkotlin-styled\u002FREADME.md#global-styles\" rel=\"nofollow noopener noreferrer\"\u003Eглобально\u003C\u002Fa\u003E, так индивидуально для конкретных компонентов. Эти обертки очень похожи на концепт \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ffaq-styling.html#what-is-css-in-js\" rel=\"nofollow noopener noreferrer\"\u003ECSS-in-JS\u003C\u002Fa\u003E. Описывая стили \u003Cem\u003Eна Котлине\u003C\u002Fem\u003E, мы опять же получаем возможность использовать краткие, понятные и единообразные языковые конструкции.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНам не нужно делать дополнительных шагов для использования этого CSS DSL, так как мы уже добавили все зависимости в конфигурацию Gradle. Вот соответствующий блок:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Edependencies {\n    \u002F\u002F...\n    \u002F\u002F Kotlin Styled (шаг 3)\n    implementation(\"org.jetbrains:kotlin-styled:5.2.1-pre.148-kotlin-1.4.21\")\n    implementation(npm(\"styled-components\", \"~5.2.1\"))\n    \u002F\u002F...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь вместо блоков вроде \u003Ccode\u003Ediv\u003C\u002Fcode\u003E или \u003Ccode\u003Eh3\u003C\u002Fcode\u003E мы можем использовать их аналоги с префиксом \u003Ccode\u003Estyled\u003C\u002Fcode\u003E, например, \u003Ccode\u003EstyledDiv\u003C\u002Fcode\u003E или \u003Ccode\u003EstyledH3\u003C\u002Fcode\u003E. Внутри их тел стили можно настраивать с помощью блока \u003Ccode\u003Ecss\u003C\u002Fcode\u003E. Например, для сдвига видеоплеера в правый верхний угол страницы, мы можем изменить наш код примерно так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EstyledDiv {\n    css {\n        position = Position.absolute\n        top = 10.px\n        right = 10.px\n    }\n    h3 {\n        +\"John Doe: Building and breaking things\"\n    }\n    img {\n        attrs {\n            src = \"https:\u002F\u002Fvia.placeholder.com\u002F640x360.png?text=Video+Player+Placeholder\"\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСкорее всего, IDEA начнет жаловаться на непонятные ссылки. Мы можем избавиться от этих ошибок, добавив импорты сверху в файле:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport kotlinx.css.*\nimport styled.*\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИли можно воспользоваться быстрыми исправлениями с помощью \u003Ccode\u003EAlt+Enter\u003C\u002Fcode\u003E для добавления импортов автоматически.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы привели довольно минималистичный пример. Не стесняйтесь поэкспериментировать – изменять стиль приложения, как душе угодно. Можете даже поиграться с CSS Grids, чтобы сделать интерфейс отзывчивым (но эта тема уже слишком сложна для этого туториала). Попробуйте сделать шрифт (свойство \u003Ccode\u003EfontFamily\u003C\u002Fcode\u003E) заголовка без засечек (значение \u003Ccode\u003Esans-serif\u003C\u002Fcode\u003E), или, например, сделать гармоничные цвета (свойство \u003Ccode\u003Ecolor\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Estep-02-first-static-page\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fstep-02-first-static-page\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep4shag-4-react--o-reakciyah-nash-pervyy-komponenta\"\u003EШаг 4. React – о реакциях. Наш первый компонент\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"osnovnaya-ideya\"\u003EОсновная идея\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБазовые строительные блоки в Реакте называются \u003Cstrong\u003Eкомпонентами\u003C\u002Fstrong\u003E. Комбинируя компоненты, часть из которых в свою может быть комбинацией других более маленьких, мы создаем приложение. Делая компоненты переиспользуемыми и обобщенными, мы можем помещать их в несколько мест в приложении, \u003Cem\u003Eне дублируя\u003C\u002Fem\u003E код и\u002Fили логику.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа самом деле, \u003Cem\u003Eкорневой элемент\u003C\u002Fem\u003E нашего рендеринга тоже можно представить как компонент. Если мы отметим его рамкой, то это будет выглядеть примерно так:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Ff70\u002F411\u002F691\u002Ff70411691aa04c00591ceefbeda5b3d9.png\" alt=\"root-component\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Ff70\u002F411\u002F691\u002Ff70411691aa04c00591ceefbeda5b3d9.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EА если посмотреть на структуру приложения, то можно найти следующие компоненты, каждый из которых имеет свою ответственность:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fa5f\u002Fb36\u002Fef7\u002Fa5fb36ef7172f53642a2e5364fb19319.png\" alt=\"split-components\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fa5f\u002Fb36\u002Fef7\u002Fa5fb36ef7172f53642a2e5364fb19319.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"kornevoy-komponent\"\u003EКорневой компонент\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте разобьем приложение на компоненты в соответствии с его структурой. Начнем с явного объявления главного компонента \u003Ccode\u003EApp\u003C\u002Fcode\u003E, который будет являться корневым. Для этого создадим файл \u003Ccode\u003EApp.kt\u003C\u002Fcode\u003E по пути \u003Ccode\u003Esrc\u002Fmain\u002Fkotlin\u003C\u002Fcode\u003E в проекте. Внутри файла опишем класс \u003Ccode\u003EApp\u003C\u002Fcode\u003E, наследующий \u003Ccode\u003ERComponent\u003C\u002Fcode\u003E (сокращение от \u003Cstrong\u003ER\u003C\u002Fstrong\u003Eeact \u003Cstrong\u003EComponent\u003C\u002Fstrong\u003E). Дженерики пока что можно оставить стандартными (\u003Ccode\u003ERProps\u003C\u002Fcode\u003E и \u003Ccode\u003ERState\u003C\u002Fcode\u003E), а потом разберемся и с ними:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport react.*\n\n@JsExport\nclass App : RComponent&lt;RProps, RState&gt;() {\n\n    override fun RBuilder.render() {\n        \u002F\u002F Помещаем сюда типобезопасный HTML!\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПереместите весь наш типобезопасный HTML внутрь новой функции \u003Ccode\u003Erender\u003C\u002Fcode\u003E. Таким образом мы поместили весь код приложения в соответствующе названный явный компонент. Теперь функция \u003Ccode\u003Emain\u003C\u002Fcode\u003E должна как-то ссылаться на \u003Ccode\u003EApp\u003C\u002Fcode\u003E. Это делается очень просто: достаточно сказать Реакту рендерить компонент \u003Ccode\u003EApp\u003C\u002Fcode\u003E как ребенка корневого элемента, используя функцию \u003Ccode\u003Echild\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Efun main() {\n    render(document.getElementById(\"root\")) {\n        child(App::class) {}\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ ходе практики мы будем создавать и использовать компоненты, так что скорее всего вы станете понимать их лучше. Но если есть желание нырнуть в Реакт поглубже, рекомендуем изучить \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fhello-world.html#how-to-read-this-guide\" rel=\"nofollow noopener noreferrer\"\u003Eофициальную документацию и гайды\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"komponent-dlya-spiska\"\u003EКомпонент для списка\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКакие части нашего приложения дублируются? Конечно же, \u003Cem\u003Eсписки видео\u003C\u002Fem\u003E – и это сразу же заметно. Так как и список непросмотренного, и список просмотренного имеют одинаковую функциональность, есть смысл создать единый компонент и переиспользовать его.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСделаем это в новом файле \u003Ccode\u003EVideoList.kt\u003C\u002Fcode\u003E. Подобно классу \u003Ccode\u003EApp\u003C\u002Fcode\u003E, создадим класс \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E, наследующий \u003Ccode\u003ERComponent\u003C\u002Fcode\u003E и содержащий HTML DSL со списком \u003Ccode\u003EunwatchedVideos\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport react.*\nimport react.dom.*\n\n@JsExport\nclass VideoList : RComponent&lt;RProps, RState&gt;() {\n\n    override fun RBuilder.render() {\n        for (video in unwatchedVideos) {\n            p {\n                +\"${video.speaker}: ${video.title}\"\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь часть со списками внутри \u003Ccode\u003EApp\u003C\u002Fcode\u003E можно сделать примерно такой:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Ediv {\n    h3 {\n        +\"Videos to watch\"\n    }\n    child(VideoList::class) {}\n\n    h3 {\n        +\"Videos watched\"\n    }\n    child(VideoList::class) {}\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОднако здесь можно заметить проблему: \u003Ccode\u003EApp\u003C\u002Fcode\u003E не управляет содержимым списка. Сейчас содержимое захардкожено и будет всегда одинаковое. Выходит, нам нужен механизм передачи списка \u003Cem\u003Eвнутрь компонента\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dobavlyaem-atributy\"\u003EДобавляем атрибуты\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь мы понимаем, что при переиспользовании компонента-списка мы бы хотели заполнять его разным содержимым. Другими словами, вместо хранения списка элементов статически, мы хотели бы задавать его внешне и передавать компоненту как атрибуты. В терминологии Реакта такие атрибуты называются \u003Ccode\u003Eprops\u003C\u002Fcode\u003E. Когда атрибуты задаются, Реакт берет на себя задачу по их передаче в компонент и по рендерингу компонента.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ нашем случае мы хотим добавить атрибут, содержащий список докладов. Давайте переработаем наш код. Создайте следующий интерфейс в файле \u003Ccode\u003EVideoList.kt\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface VideoListProps : RProps {\n    var videos: List&lt;Video&gt;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь изменим объявление класса \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E, чтобы он использовал этот атрибут:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@JsExport\nclass VideoList : RComponent&lt;VideoListProps, RState&gt;() {\n\n    override fun RBuilder.render() {\n        for (video in props.videos) {\n            p {\n                key = video.id.toString()\n                +\"${video.speaker}: ${video.title}\"\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТак как содержимое компонента теперь потенциально динамично (то есть переданные в рантайме атрибуты могут меняться, мы так и будем делать в следующих шагах), следует проставлять свойство \u003Ccode\u003Ekey\u003C\u002Fcode\u003E в каждый элемент списка. Он помогает Реакту понять, какие части списка нужно обновить, а какие можно оставить без изменений – хорошая и почти бесплатная оптимизация! Больше информации насчет списков и ключей можно найти, например, в \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Flists-and-keys.html\" rel=\"nofollow noopener noreferrer\"\u003Eофициальном гайде Реакта\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНаконец, на месте использования \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E (внутри \u003Ccode\u003EApp\u003C\u002Fcode\u003E) нам остается передать правильные атрибуты. Подставьте \u003Ccode\u003EunwatchedVideos\u003C\u002Fcode\u003E и \u003Ccode\u003EwatchedVideos\u003C\u002Fcode\u003E примерно так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Echild(VideoList::class) {\n    attrs.videos = unwatchedVideos\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПроверьте в браузере, что списки рендерятся, как задумано. Таким образом, мы инкапсулировали обязанность рендеринга списка видео внутри соответствующего компонента. Это должно укорачивать исходный код и делать его более легкочитаемым и понимаемым как для нас, так и для коллег.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"umenshaem-gromozdkost-vyzova\"\u003EУменьшаем громоздкость вызова\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли вам тоже не очень нравится предыдущая конструкция, мы можем улучшить ее, используя крутую котлиновскую фичу под названием \u003Ca href=\"https:\u002F\u002Fkotlinlang.org\u002Fdocs\u002Freference\u002Flambdas.html#function-literals-with-receiver\" rel=\"nofollow noopener noreferrer\"\u003Eфункция с получателем\u003C\u002Fa\u003E. Выделим функцию, которая делает доступ к компонентам легче: она выполняет то же самое, что и предыдущая конструкция, но изменяет синтаксис использования:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Efun RBuilder.videoList(handler: VideoListProps.() -&gt; Unit): ReactElement {\n    return child(VideoList::class) {\n        attrs.handler()\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EРасскажем, что происходит в этом коде: мы определяем функцию \u003Ccode\u003EvideoList\u003C\u002Fcode\u003E как \u003Ca href=\"https:\u002F\u002Fkotlinlang.org\u002Fdocs\u002Freference\u002Fextensions.html\" rel=\"nofollow noopener noreferrer\"\u003Eрасширение\u003C\u002Fa\u003E для типа \u003Ccode\u003ERBuilder\u003C\u002Fcode\u003E. Функция принимает единственный параметр \u003Ccode\u003Ehandler\u003C\u002Fcode\u003E – функцию-расширение для \u003Ccode\u003EVideoListProps\u003C\u002Fcode\u003E, возвращающую \u003Ccode\u003EUnit\u003C\u002Fcode\u003E. Функция оборачивает вызов \u003Ccode\u003Echild\u003C\u002Fcode\u003E (который мы делали изначально для вставки \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E), и вызывает \u003Ccode\u003Ehandler\u003C\u002Fcode\u003E на объекте \u003Ccode\u003Eattrs\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОсновной смысл такой функции – облегчение синтаксиса использования нашего компонента: теперь мы можем писать просто\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EvideoList {\n    videos = unwatchedVideos\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ общем, мы убираем из вызова не сильно информативные слова типа \u003Ccode\u003Echild\u003C\u002Fcode\u003E, \u003Ccode\u003Eclass\u003C\u002Fcode\u003E и \u003Ccode\u003Eattrs\u003C\u002Fcode\u003E, оставляя только специфичные для конкретного компонента символы. Аналогичные функции можно писать для всех компонентов, которые вы описываете. Запомните этот трюк! При желании потренироваться уже сейчас можете попробовать это проделать для класса \u003Ccode\u003EApp\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dobavlyaem-interaktivnost\"\u003EДобавляем интерактивность\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОсновная цель нашего компонента-списка – задавать видео для показа в видеоплеере. Чтобы это сделать, нужно позволить пользователю взаимодействовать с элементами списка. Начнем с простого: будем показывать выбранное пользователем видео в диалоге \u003Ccode\u003Ealert\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля этого модифицируем код внутри функции \u003Ccode\u003EVideoList.render\u003C\u002Fcode\u003E. Сделаем так, чтобы при клике на элемент \u003Ccode\u003Ep\u003C\u002Fcode\u003E соответствующее сообщение показывалось бы в диалоге:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Ep {\n    key = video.id.toString()\n    attrs {\n        onClickFunction = {\n            window.alert(\"Clicked $video!\")\n        }\n    }\n    +\"${video.speaker}: ${video.title}\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли IntelliJ IDEA просит добавить импорты, это можно сделать по нажатию \u003Ccode\u003EAlt+Enter\u003C\u002Fcode\u003E. Или можно добавить импорты вручную:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport kotlinx.html.js.onClickFunction\nimport kotlinx.browser.window\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь при клике на элементе списка в браузере мы увидим всплывающее сообщение о выбранном элементе:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F07f\u002F85e\u002F867\u002F07f85e8677b33e952fdc2734aee60e95.png\" alt=\"alert\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F07f\u002F85e\u002F867\u002F07f85e8677b33e952fdc2734aee60e95.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EОформлять значение \u003Ccode\u003EonClickFunction\u003C\u002Fcode\u003E как лямбду довольно коротко, и это удобно как минимум для прототипирования. Однако на данный момент эквивалентность ссылок на функции в Kotlin\u002FJS работает \u003Ca href=\"https:\u002F\u002Fyoutrack.jetbrains.com\u002Fissue\u002FKT-15101\" rel=\"nofollow noopener noreferrer\"\u003Eне очень очевидно\u003C\u002Fa\u003E. Поэтому передача лямбды на самом деле не сильно эффективна в плане производительности. Если вам нужна максимальная эффективность, необходимо сохранять ссылки на функции в неменяющихся во время выполнения переменных и передавать в качестве значений для \u003Ccode\u003EonClickFunction\u003C\u002Fcode\u003E и других подобных свойств эти переменные.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dobavlyaem-sostoyanie\"\u003EДобавляем состояние\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНе устали?\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте сделаем настоящий селектор видео вместо вывода всплывающего сообщения. Будем подсвечивать выбранное видео треугольником (\u003Ccode\u003E|&gt;\u003C\u002Fcode\u003E). Реакт нам поможет – он позволяет ввести некоторое \u003Cem\u003Eсостояние\u003C\u002Fem\u003E для компонента. Это будет очень похоже на добавление атрибутов – надо объявить интерфейс:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface VideoListState : RState {\n    var selectedVideo: Video?\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДальше надо сделать следующее:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003EПодредактировать объявление класса \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E, чтобы в качестве типа состояния он использовал \u003Ccode\u003EVideoListState\u003C\u002Fcode\u003E – нужно унаследовать компонент от \u003Ccode\u003ERComponent&lt;..., VideoListState&gt;\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003EПри рендеринге списка для выбранного видео мы должны выводить треугольник в качестве префикса.\u003C\u002Fli\u003E\n\u003Cli\u003EВнутри \u003Ccode\u003EonClickFunction\u003C\u002Fcode\u003E надо записывать в состояние \u003Ccode\u003EselectedVideo\u003C\u002Fcode\u003E то видео, которое соответствует кликнутому элементу. Чтобы компонент перерисовывался при изменении состояния, код для изменения нужно обернуть лямбду и передать ее в функцию \u003Ccode\u003EsetState\u003C\u002Fcode\u003E. \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКогда проделаем это, мы получим такой класс:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@JsExport\nclass VideoList : RComponent&lt;VideoListProps, VideoListState&gt;() {\n\n    override fun RBuilder.render() {\n        for (video in props.videos) {\n            p {\n                key = video.id.toString()\n                attrs {\n                    onClickFunction = {\n                        setState {\n                            selectedVideo = video\n                        }\n                    }\n                }\n                if (video == state.selectedVideo) {\n                    +\"|&gt; \"\n                }\n                +\"${video.speaker}: ${video.title}\"\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003E\u003Cstrong\u003EСостояние стоит модифицировать только внутри \u003Ccode\u003EsetState\u003C\u002Fcode\u003E\u003C\u002Fstrong\u003E. Так Реакт сможет обнаружить изменения и перерисовать нужные части UI быстро и эффективно.\u003C\u002Fblockquote\u003E\u003Cp\u003EНа этом шаге у нас все, но более подробно о состоянии можно почитать в официальном \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Ffaq-state.html\" rel=\"nofollow noopener noreferrer\"\u003EReact FAQ\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Estep-03-first-component\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fstep-03-first-component\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep5shag-5-rabotaem-sovmestno-kompoziciya-komponentova\"\u003EШаг 5. Работаем совместно. Композиция компонентов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСделанные нами на предыдущем шаге пара списков сами по себе вполне работают. Однако, если мы кликнем по одному видео в каждом из списков, мы можем выбрать \u003Cem\u003Eдва видео\u003C\u002Fem\u003E одновременно. Это неправильно, ведь у нас только один плеер :)\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F188\u002F255\u002F3e3\u002F1882553e39a1d6e05dc7f3b637e2bb9d.png\" alt=\"pair\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F188\u002F255\u002F3e3\u002F1882553e39a1d6e05dc7f3b637e2bb9d.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПо-хорошему, у обоих списков должно быть единое состояние – выбранное видео, которое будет одним на все приложение. Но единое состояние не может (и не должно) храниться в разных компонентах. Принято выносить состояние наверх (как еще говорят, \"поднимать\" состояние).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"vynos-sostoyaniya-naverh\"\u003EВынос состояния наверх\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы не прибивать гвоздями разные компоненты друг к другу и не создавать спагетти-код, можно воспользоваться иерархией компонентов Реакта: передавать атрибуты из родительского компонента. Если компонент хочет изменять состояние соседнего компонента, это следует делать через общего родителя. Значит, состояние должно быть не в соседнем компоненте, а именно в родителе. Миграция состояния из компонента к родителю называется \u003Cstrong\u003Eвыносом\u003C\u002Fstrong\u003E состояния. Давайте выносить его в нашем случае! Для этого нам нужно добавить состояние для нашего родительского компонента, \u003Ccode\u003EApp\u003C\u002Fcode\u003E. Будем действовать примерно так же, как и с состоянием для \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОбъявим интерфейс:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface AppState : RState {\n    var currentVideo: Video?\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИ сошлемся на него в классе \u003Ccode\u003EApp\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@JsExport\nclass App : RComponent&lt;RProps, AppState&gt;()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EУдалим \u003Ccode\u003EVideoListState\u003C\u002Fcode\u003E, так как мы теперь будем хранить эту информацию выше. Получается, мы вообще убрали состояние у списка, так что вернем его состояние к стандартному в описании класса:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@JsExport\nclass VideoList : RComponent&lt;VideoListProps, RState&gt;()\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь передадим вниз состояние выбранного видео из \u003Ccode\u003EApp\u003C\u002Fcode\u003E в \u003Ccode\u003EVideoList\u003C\u002Fcode\u003E как атрибут. Добавим свойство в интерфейс \u003Ccode\u003EVideoListProps\u003C\u002Fcode\u003E, которое будет содержать выбранное видео:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface VideoListProps : RProps {\n    var videos: List&lt;Video&gt;\n    var selectedVideo: Video?\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПоправим условие для показа треугольника выбранного видео, чтобы оно использовало атрибуты вместо состояния:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eif (video == props.selectedVideo) {\n    +\"|&gt; \"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНо есть еще одна проблема, которую создал наш рефакторинг: у компонента нет доступа к родительскому состоянию, так что вызов \u003Ccode\u003EsetState\u003C\u002Fcode\u003E внутри \u003Ccode\u003EonClickFunction\u003C\u002Fcode\u003E не сможет сделать ничего полезного. Чтобы побороть это и в итоге опять получить работающее приложение, давайте поднимем кое-что еще.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"peredacha-obrabotchikov\"\u003EПередача обработчиков\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EК сожалению, Реакт не позволяет изменять состояние родительского компонента напрямую, как бы мы этого ни хотели. Но мы можем поступить по-другому: перенести логику обработки действия пользователя в атрибут и передавать его из родителя. Помните, что в Котлине у переменных может быть \u003Ca href=\"https:\u002F\u002Fkotlinlang.org\u002Fdocs\u002Freference\u002Flambdas.html#function-types\" rel=\"nofollow noopener noreferrer\"\u003Eфункциональный тип\u003C\u002Fa\u003E? Добавим еще в одно свойство в интерфейс – функцию, принимающую \u003Ccode\u003EVideo\u003C\u002Fcode\u003E и возвращающую \u003Ccode\u003EUnit\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface VideoListProps : RProps {\n    var videos: List&lt;Video&gt;\n    var selectedVideo: Video?\n    var onSelectVideo: (Video) -&gt; Unit\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИ соответственно поменяем \u003Ccode\u003EonClickFunction\u003C\u002Fcode\u003E на вызов этой функции из атрибутов:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EonClickFunction = {\n    props.onSelectVideo(video)\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь мы сможем передавать выбранное видео как атрибут и вынести логику \u003Cem\u003Eвыбора\u003C\u002Fem\u003E видео в родительский компонент, где и будем менять состояние. Иными словами, мы хотим поднять логику обработки кликов в родителя. Обновим оба места использования \u003Ccode\u003EvideoList\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EvideoList {\n    videos = unwatchedVideos\n    selectedVideo = state.currentVideo\n    onSelectVideo = { video -&gt;\n        setState {\n            currentVideo = video\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВторое место отличается присваиванием \u003Ccode\u003EwatchedVideos\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПри необходимости перекомпилируйте проект и убедитесь, что теперь все работает логично: при выборе видео в двух списках, треугольник перепрыгивает между списками, а не дублируется. Возможно, вы даже удивитесь, как все оказалось просто.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Estep-04-composing-components\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fstep-04-composing-components\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep6shag-6-bolshe-komponentova\"\u003EШаг 6. Больше компонентов!\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы сделали один компонент отдельным и самодостаточным, а также оставили у него возможность взаимодействовать с приложением. Давайте проделаем то же самое для остальных частей приложения.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"vynosim-komponent-videopleera\"\u003EВыносим компонент видеоплеера\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕще одна часть приложения, которую стоит вынести как обособленную единицу – это видеоплеер (его мы все еще заменяем картинкой-заглушкой). Давайте подумаем, какие атрибуты понадобятся для видеоплеера: это автор видео, название и ссылка. На самом деле, все эти свойства уже имеет объект типа \u003Ccode\u003EVideo\u003C\u002Fcode\u003E, так что будем передавать его как атрибут. Создадим новый компонент \u003Ccode\u003EVideoPlayer\u003C\u002Fcode\u003E в файле \u003Ccode\u003EVideoPlayer.kt\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport kotlinx.css.*\nimport kotlinx.html.js.onClickFunction\nimport react.*\nimport react.dom.*\nimport styled.*\n\nexternal interface VideoPlayerProps : RProps {\n    var video: Video\n}\n\n@JsExport\nclass VideoPlayer : RComponent&lt;VideoPlayerProps, RState&gt;() {\n    override fun RBuilder.render() {\n        styledDiv {\n            css {\n                position = Position.absolute\n                top = 10.px\n                right = 10.px\n            }\n            h3 {\n                +\"${props.video.speaker}: ${props.video.title}\"\n            }\n            img {\n                attrs {\n                    src = \"https:\u002F\u002Fvia.placeholder.com\u002F640x360.png?text=Video+Player+Placeholder\"\n                }\n            }\n        }\n    }\n}\n\nfun RBuilder.videoPlayer(handler: VideoPlayerProps.() -&gt; Unit): ReactElement {\n    return child(VideoPlayer::class) {\n        this.attrs(handler)\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь заменим предыдущий \u003Ccode\u003EstyledDiv\u003C\u002Fcode\u003E с видеоплеером (в файле \u003Ccode\u003EApp.kt\u003C\u002Fcode\u003E) на только что вынесенный компонент. Будем его отрисовывать, только если выбрано какое-то видео – воспользуемся комбинацией оператора безопасного вызова и функции \u003Ccode\u003Elet\u003C\u002Fcode\u003E, тогда переданный в \u003Ccode\u003Elet\u003C\u002Fcode\u003E блок кода будет выполняться, если \u003Ccode\u003EcurrentVideo\u003C\u002Fcode\u003E не равно \u003Ccode\u003Enull\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Estate.currentVideo?.let { currentVideo -&gt;\n    videoPlayer {\n        video = currentVideo\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dobavlyaem-i-prisoedinyaem-knopku\"\u003EДобавляем и присоединяем кнопку\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПока что в приложении нет способа двигать видео между списками непросмотренных и просмотренных. Для решения этой задачи добавим кнопку в \u003Ccode\u003EVideoPlayer\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы хотим двигать элементы между разными списками, а они находятся за пределами нашего компонента \u003Ccode\u003EVideoPlayer\u003C\u002Fcode\u003E. Вспомним, что в подобных случаях нам надо выносить в общего родителя логику обработки нажатия кнопки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПопробуем сделать кнопку-переключатель. При нажатии ее состояние, например, текст, будет изменяться в зависимости от того, просмотрено видео или нет. Для этого будем передавать еще и состояние кнопки.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДобавим еще свойств в интерфейс \u003Ccode\u003EVideoPlayerProps\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface VideoPlayerProps : RProps {\n    var video: Video\n    var onWatchedButtonPressed: (Video) -&gt; Unit\n    var unwatchedVideo: Boolean\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы уже создали несколько компонентов, так что реализация кнопки не должна быть сложной задачей. Попробуем использовать атрибуты для изменения CSS свойств: будем раскрашивать кнопку динамически на основе состояния видео. Добавим следующий HTML DSL в метод \u003Ccode\u003Erender\u003C\u002Fcode\u003E видеоплеера, между тегами \u003Ccode\u003Eh3\u003C\u002Fcode\u003E и \u003Ccode\u003Eimg\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EstyledButton {\n    css {\n        display = Display.block\n        backgroundColor = if (props.unwatchedVideo) Color.lightGreen else Color.red\n    }\n    attrs {\n        onClickFunction = {\n            props.onWatchedButtonPressed(props.video)\n        }\n    }\n    if (props.unwatchedVideo) {\n        +\"Mark as watched\"\n    } else {\n        +\"Mark as unwatched\"\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"peremeschaem-spiski-video-v-sostoyanie-prilozheniya\"\u003EПеремещаем списки видео в состояние приложения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПеред тем как изменить вызов \u003Ccode\u003EVideoPlayer\u003C\u002Fcode\u003E, подумаем о логике его работы.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПри клике на кнопку видео должно быть либо перенесено из списка \u003Ccode\u003Eunwatched\u003C\u002Fcode\u003E в \u003Ccode\u003Ewatched\u003C\u002Fcode\u003E, либо наоборот.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТо есть списки могут изменяться. Давайте тогда перенесем их в состояние приложения! Опять добавим дополнительные свойства в интерфейс:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface AppState : RState {\n    var currentVideo: Video?\n    var unwatchedVideos: List&lt;Video&gt;\n    var watchedVideos: List&lt;Video&gt;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНачальные значения состояния можно задать в методе \u003Ccode\u003Einit\u003C\u002Fcode\u003E. Сделаем это, переопределив метод в классе \u003Ccode\u003EApp\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eoverride fun AppState.init() {\n    unwatchedVideos = listOf(\n        KotlinVideo(1, \"Building and breaking things\", \"John Doe\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\"),\n        KotlinVideo(2, \"The development process\", \"Jane Smith\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\"),\n        KotlinVideo(3, \"The Web 7.0\", \"Matt Miller\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\")\n    )\n    watchedVideos = listOf(\n        KotlinVideo(4, \"Mouseless development\", \"Tom Jerry\", \"https:\u002F\u002Fyoutu.be\u002FPsaFVLr8t4E\")\n    )\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь можно удалить \u003Ccode\u003EunwatchedVideos\u003C\u002Fcode\u003E и \u003Ccode\u003EwatchedVideos\u003C\u002Fcode\u003E из файла \u003Ccode\u003EMain.kt\u003C\u002Fcode\u003E, а в файле \u003Ccode\u003EMain.kt\u003C\u002Fcode\u003E заменить все вызовы (\u003Ccode\u003Eun\u003C\u002Fcode\u003E)\u003Ccode\u003EwatchedVideos\u003C\u002Fcode\u003E, которые наверняка IDE уже успела подсветить как ошибочные, на \u003Ccode\u003Estate.\u003C\u002Fcode\u003E(\u003Ccode\u003Eun\u003C\u002Fcode\u003E)\u003Ccode\u003EwatchedVideos\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНаконец, подкорректируем вызов видеоплеера. Он будет выглядеть вот так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EvideoPlayer {\n    video = currentVideo\n    unwatchedVideo = currentVideo in state.unwatchedVideos\n    onWatchedButtonPressed = {\n        if (video in state.unwatchedVideos) {\n            setState {\n                unwatchedVideos -= video\n                watchedVideos += video\n            }\n        } else {\n            setState {\n                watchedVideos -= video\n                unwatchedVideos += video\n            }\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВернитесь в браузер, выберите видео, нажмите на кнопку пару раз и убедитесь, что видео перемещается между двумя списками.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТаким образом, мы реализовали основную логику нашего приложения. Будет здорово, если вы поиграетесь со стилями кнопки, и выберете тот, который вам больше всего по душе. Можете даже попробовать вынести кнопку в отдельный переиспользуемый компонент!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВремя откинуться на спинку кресла и переложить тяжелую работу на других. В следующем шаге поговорим об использовании готовых и общедоступных Реакт компонентов из Котлина.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Estep-05-more-components\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fstep-05-more-components\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep7shag-7-ispolzovanie-npm-paketova\"\u003EШаг 7. Использование NPM пакетов\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EХотя мы уже неплохо продвинулись, в приложении все еще отсутствуют жизненно важные части. Вместо написания всего с нуля, попробуем использовать богатую экосистему, построенную вокруг Реакта. В ней есть тонна уже готовых компонентов, так что давайте действительно не переизобретать велосипед, а использовать их.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПервая и самая очевидная недостающая функциональность – это видеоплеер.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dobavlyaem-komponent-videopleera\"\u003EДобавляем компонент видеоплеера\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНужно заменить нашу заглушку на компонент, способный показывать видео с Ютуба. Воспользуемся компонентом из библиотеки \u003Ccode\u003Ereact-youtube-lite\u003C\u002Fcode\u003E. Его документацию и API можно найти в \u003Ca href=\"https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Freact-youtube-lite\" rel=\"nofollow noopener noreferrer\"\u003EREADME\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВспомним самое начало практики. Там мы видели зависимость на \u003Ccode\u003Ereact-youtube-lite\u003C\u002Fcode\u003E, объявленную в файле Gradle. Вот то место:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Edependencies {\n    \u002F\u002F ...\n    \u002F\u002F Video Player (шаг 7)\n    implementation(npm(\"react-youtube-lite\", \"1.0.1\"))\n    \u002F\u002F ...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВы понимаете правильно – NPM зависимости могут быть добавлены в Gradle проект с помощью функции \u003Ccode\u003Enpm\u003C\u002Fcode\u003E. \u003Ccode\u003Eyarn\u003C\u002Fcode\u003E, который вызывается Kotlin\u002FJS Gradle плагином под капотом, позаботится о загрузке, установке и обновлении этих зависимостей.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКогда мы хотим использовать NPM модули из Котлина, необходимо рассказать компилятору о сигнатурах: что можно вызывать, присваивать или читать. После этого все будет статически типизировано, и IDE сможет помогать нам писать обычный код на Котлине. Объявлять декларации для каждого внешнего модуля надо в отдельном файле. Создадим файл \u003Ccode\u003EReactYouTube.kt\u003C\u002Fcode\u003E со следующим содержимым:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@file:JsModule(\"react-youtube-lite\")\n@file:JsNonModule\n\nimport react.*\n\n@JsName(\"ReactYouTubeLite\")\nexternal val reactPlayer: RClass&lt;dynamic&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИмпорты и экспорты в JavaScript – относительно непростая тема, поэтому иногда бывает сложно найти правильную комбинацию аннотаций, чтобы компилятор Котлина импортировал все правильно. Последние две строчки в нашем случае – это эквивалент \u003Ccode\u003Erequire(\"react-youtube-lite\").default\u003C\u002Fcode\u003E в JS. Они говорят компилятору: \"мы уверены, что в рантайме тут получится компонент, соответствующий \u003Ccode\u003ERClass&lt;dynamic&gt;\u003C\u002Fcode\u003E\".\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"tipizirovannye-obertki-dlya-komponenta\"\u003EТипизированные обертки для компонента\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОднако, оставив все в таком виде, мы откажемся от большого количества возможностей Котлина. Объявление \u003Ccode\u003Edynamic\u003C\u002Fcode\u003E типа говорит компилятору, что значение этого типа может быть любым. Компилятор не будет проверять такие объекты, а значит есть высокий риск, что что-то сломается во время исполнения (например, в проде).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EК счастью, мы уже видели, как в Котлине объявляются реактовские атрибуты (как \u003Ccode\u003Eexternal\u003C\u002Fcode\u003E интерфейс), а их имена мы можем найти опять же в README библиотеки. Так что на самом деле написание типобезопасных деклараций – довольно простая задача. Мы можем объявить только те свойства, которые будем использовать – в первую очередь нам будет полезно задавать ссылку на видео. Поменяем декларацию видеоплеера вот так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@file:JsModule(\"react-youtube-lite\")\n@file:JsNonModule\n\nimport react.*\n\n@JsName(\"ReactYouTubeLite\")\nexternal val reactPlayer: RClass&lt;ReactYouTubeProps&gt;\n\nexternal interface ReactYouTubeProps : RProps {\n    var url: String\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСамое время заменить скучный серый прямоугольник внутри компонента \u003Ccode\u003EVideoPlayer\u003C\u002Fcode\u003E на только что задекларированный настоящий плеер! Удалим тег \u003Ccode\u003Eimg\u003C\u002Fcode\u003E и заменим его на следующее:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EreactPlayer {\n    attrs.url = props.video.videoUrl\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dobavlyaem-knopki-shera\"\u003EДобавляем кнопки шера\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПолучать удовольствие от докладов с KotlinConf лучше вместе (что является правдой и для многих других занятий). Кнопки шера – общепризнанный способ поделиться с друзьями и коллегами качественным контентом. Такие кнопки могут поддерживать, например, мессенджеры и электронную почту. Для кнопок есть уже существующие Реакт компоненты, например, из пакета \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fnygardk\u002Freact-share\u002Fblob\u002Fmaster\u002FREADME.md\" rel=\"nofollow noopener noreferrer\"\u003Ereact-share\u003C\u002Fa\u003E. Этот пакет тоже уже объявлен в конфигурации Gradle:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Edependencies {\n    \u002F\u002F ...\n    \u002F\u002F Share Buttons (шаг 7)\n    implementation(npm(\"react-share\", \"~4.2.1\"))\n    \u002F\u002F ...\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОпять напишем декларации. Если посмотрим на \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fnygardk\u002Freact-share\u002Fblob\u002Fmaster\u002Fdemo\u002FDemo.tsx\" rel=\"nofollow noopener noreferrer\"\u003Eпримеры\u003C\u002Fa\u003E с ГитХаба, увидим, что кнопки состоят из двух компонентов: например, \u003Ccode\u003EEmailShareButton\u003C\u002Fcode\u003E и \u003Ccode\u003EEmailIcon\u003C\u002Fcode\u003E. И почти все из них имеют одинаковые атрибуты. Файл с декларациями получается примерно следующий; назовем его \u003Ccode\u003EReactShare.kt\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E@file:JsModule(\"react-share\")\n@file:JsNonModule\n\nimport react.RClass\nimport react.RProps\n\n@JsName(\"EmailIcon\")\nexternal val emailIcon: RClass&lt;IconProps&gt;\n\n@JsName(\"EmailShareButton\")\nexternal val emailShareButton: RClass&lt;ShareButtonProps&gt;\n\n@JsName(\"TelegramIcon\")\nexternal val telegramIcon: RClass&lt;IconProps&gt;\n\n@JsName(\"TelegramShareButton\")\nexternal val telegramShareButton: RClass&lt;ShareButtonProps&gt;\n\nexternal interface ShareButtonProps : RProps {\n    var url: String\n}\n\nexternal interface IconProps : RProps {\n    var size: Int\n    var round: Boolean\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте добавим две кнопки над компонентом видеоплеера. Напишем следующий код перед вызовом \u003Ccode\u003EreactPlayer\u003C\u002Fcode\u003E (обернем в \u003Ccode\u003EstyledDiv\u003C\u002Fcode\u003E, чтобы сделать расположение компонентов подходящим):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003EstyledDiv {\n    css {\n        display = Display.flex\n        marginBottom = 10.px\n    }\n    emailShareButton {\n        attrs.url = props.video.videoUrl\n        emailIcon {\n            attrs.size = 32\n            attrs.round = true\n        }\n    }\n    telegramShareButton {\n        attrs.url = props.video.videoUrl\n        telegramIcon {\n            attrs.size = 32\n            attrs.round = true\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь можно проверить, что кнопки действительно работают. Если кликнуть по ним, должно открыться окно. Если же ничего не происходит, возможно, у вас включен скрывающий такие кнопки блокировщик рекламы.\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F1b8\u002F38d\u002F927\u002F1b838d92717d355eb47cdc830848afad.png\" alt=\"pair\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F1b8\u002F38d\u002F927\u002F1b838d92717d355eb47cdc830848afad.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли хотите, можете написать декларации для других кнопок в этой библиотеке и тоже добавить их на экран.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Estep-06-packages-from-npm\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fstep-06-packages-from-npm\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep8shag-8-ispolzuem-vneshnee-rest-apia\"\u003EШаг 8. Используем внешнее REST API\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВас может расстраивать, что до сих пор мы показываем только очень ограниченный захардкоженный список видео. Давайте теперь заменим эти данные реальными, получать которые мы будем из REST API.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля этой практики мы создали небольшое API, доступное по ссылке \u003Ca href=\"https:\u002F\u002Fmy-json-server.typicode.com\u002Fkotlin-hands-on\u002Fkotlinconf-json\u002Fvideos\u002F1\" rel=\"nofollow noopener noreferrer\"\u003Ehttps:\u002F\u002Fmy-json-server.typicode.com\u002Fkotlin-hands-on\u002Fkotlinconf-json\u002Fvideos\u002F1\u003C\u002Fa\u003E. У этого API только одна ручка – \u003Ccode\u003Evideos\u003C\u002Fcode\u003E, которая может возвращать информацию видео по его номеру. Попробуйте поделать запросы к этому API из браузера. Вы увидите, что возвращаемые объекты имеют ту же структуру, что и объекты \u003Ccode\u003EVideo\u003C\u002Fcode\u003E в нашем коде (какое совпадение \u003Ccode\u003E;)\u003C\u002Fcode\u003E). В следующей секции мы обсудим, как приложение может запрашивать эти данные и преобразовывать их в наши котлиновские объекты.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"ispolzovanie-funkcionalnosti-js-iz-kotlina\"\u003EИспользование функциональности JS из Котлина\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДаже без добавления библиотек браузеры дают множество возможностей. В стандартной библиотеке Kotlin\u002FJS есть обертки как раз для этих стандартных браузерных вызовов, позволяющие делать эти вызовы комфортно и типобезопасно прямо из кода на Котлине. Мы воспользуемся обертками для \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FFetch_API\" rel=\"nofollow noopener noreferrer\"\u003EFetch API\u003C\u002Fa\u003E, чтобы делать HTTP запросы для обращения к REST API.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТипичный способ создавать асинхронные программы в экосистеме JavaScript – использовать колбеки. При этом приходится раз за разом дожидаться выполнения промисов, заключая функции внутрь функций, которые в свою очередь тоже могут быть заключены в других функциях. Чем сложнее код, тем тяжелее будет синтаксис из-за отступов и скобок. Код будет съезжать вправо, его будет сложнее читать и понимать весь поток выполнения, как нам, так и другим разработчикам. Несмотря на эти недостатки, в нашем случае код с колбеками может быть довольно простым:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Ewindow.fetch(\"https:\u002F\u002Furl...\").then {\n    it.json().then {\n        it.unsafeCast&lt;Video&gt;()\n        \u002F\u002F...\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EНо мы будем использовать другой подход\u003C\u002Fstrong\u003E. Обратимся к котлиновским корутинам, более красивому и структурированному способу добиться той же цели.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"korutiny-vmesto-kolbekov\"\u003EКорутины вместо колбеков\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКорутины и структурированная конкурентность (structured concurrency) – гигантская тема в Котлине. Если вы хотите хорошо в них разобраться, попробуйте пройти \u003Ca href=\"https:\u002F\u002Fplay.kotlinlang.org\u002Fhands-on\u002FIntroduction%20to%20Coroutines%20and%20Channels\u002F\" rel=\"nofollow noopener noreferrer\"\u003Eпрактику по корутинам\u003C\u002Fa\u003E. Сейчас же мы обсудим их только поверхностно. Начнем с добавления библиотеки корутин в зависимости нашего проекта.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКак и другие зависимости в нашей практики, соответствующий Gradle код уже присутствует в конфигурации еще с момента начальной настройки проекта:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Edependencies {\n    \u002F\u002F...\n    \u002F\u002F Coroutines (шаг 8)\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте теперь запросим информацию о видео, используя корутины!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"zaprashivaem-pervoe-video\"\u003EЗапрашиваем первое видео\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВнутри \u003Ccode\u003EApp.kt\u003C\u002Fcode\u003E или в новом файле, напишем функцию, которая будет получать видео из REST API:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Esuspend fun fetchVideo(id: Int): Video {\n    val response = window\n        .fetch(\"https:\u002F\u002Fmy-json-server.typicode.com\u002Fkotlin-hands-on\u002Fkotlinconf-json\u002Fvideos\u002F$id\")\n        .await()\n        .json()\n        .await()\n    return response as Video\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EС помощью быстрых исправлений импортируем нужные объекты и функции. Или добавим импорты наверху файла вручную:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eimport kotlinx.browser.window\nimport kotlinx.coroutines.*\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПопробуем понять, что происходит в этой \u003Cem\u003Esuspend функции\u003C\u002Fem\u003E. Мы запрашиваем информацию о видео с помощью функции \u003Ccode\u003Efetch\u003C\u002Fcode\u003E, подставляя \u003Ccode\u003Eid\u003C\u002Fcode\u003E видео в ссылку на API. Ждем готовности ответа (\u003Ccode\u003Eawait\u003C\u002Fcode\u003E), преобразуем ответ к JSON, опять ждем уже готовности преобразования. После этого мы кастуем результат к объявленному в ходе нашей практики \u003Ccode\u003Eexternal interface Video\u003C\u002Fcode\u003E и возвращаем его из функции. Скорее всего, IDE подсветит каст как непроверенный – но это нормально при использовании JavaScript вызовов типа \u003Ccode\u003Efetch\u003C\u002Fcode\u003E: компилятор \u003Cem\u003Eне может быть уверен наверняка\u003C\u002Fem\u003E, что на этом месте получится экземпляр \u003Ccode\u003EVideo\u003C\u002Fcode\u003E. Компилятор вынужден верить разработчику. \u003Cstrong\u003EПримечание переводчика\u003C\u002Fstrong\u003E: чтобы убирать такие предупреждения, можно либо заглушать их с помощью аннотации \u003Ccode\u003E@Suppress\u003C\u002Fcode\u003E, либо использовать метод \u003Ccode\u003EunsafeCast\u003C\u002Fcode\u003E (\u003Ccode\u003Eresponse.unsafeCast&lt;Video&gt;()\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EОбсудим происходящее чуть подробнее. Вызовы функций \u003Ccode\u003Ewindow.fetch\u003C\u002Fcode\u003E и \u003Ccode\u003Ejson\u003C\u002Fcode\u003E на самом деле возвращают промис. Мы могли бы передать колбек, который выполнится при готовности результата промиса. Однако так как в нашем проекте доступны корутины, мы можем вместо возни с колбеками просто подождать (\u003Ccode\u003Eawait\u003C\u002Fcode\u003E) готовности результата. Таким образом, написанный код выглядит последовательным, но остается неблокирующим. Когда вызывается \u003Ccode\u003Eawait\u003C\u002Fcode\u003E, на самом деле выполнение всей функции приостанавливается (отсюда требование помечать такую функцию как \u003Ccode\u003Esuspend\u003C\u002Fcode\u003E). Когда результат промиса готов, выполнение функции продолжается.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"ispolzuem-suspend-funkciyu\"\u003EИспользуем suspend функцию\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДавайте наконец запросим список видео, например, взяв первые 25. Для этого объявим функцию \u003Ccode\u003EfetchVideos\u003C\u002Fcode\u003E, вызывающую предыдущую функцию 25 раз. Так как мы хотим одновременного выполнения запросов, мы можем использовать еще одну функцию корутин для запуска suspend кода – \u003Ccode\u003Easync\u003C\u002Fcode\u003E. Тогда реализация будет выглядеть примерно так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Esuspend fun fetchVideos(): List&lt;Video&gt; = coroutineScope {\n    (1..25).map { id -&gt;\n        async {\n            fetchVideo(id)\n        }\n    }.awaitAll()\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля правильности \u003Ca href=\"https:\u002F\u002Fkotlinlang.org\u002Fdocs\u002Freference\u002Fcoroutines\u002Fbasics.html#structured-concurrency\" rel=\"nofollow noopener noreferrer\"\u003Eструктурированной конкурентности\u003C\u002Fa\u003E мы оборачиваем весь код функции в \u003Ccode\u003EcoroutineScope\u003C\u002Fcode\u003E. Внутри мы запускаем 25 асинхронных задач, по одной на запрос, и ждем выполнения их всех.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВоспользуемся возможностью еще раз напомнить о \u003Ca href=\"https:\u002F\u002Fplay.kotlinlang.org\u002Fhands-on\u002FIntroduction%20to%20Coroutines%20and%20Channels\u002F\" rel=\"nofollow noopener noreferrer\"\u003Eпрактике по корутинам\u003C\u002Fa\u003E, где обо всем этом рассказывается намного более полно.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПосле получения реальных данных настает время использовать их в нашем приложении. Чтобы сделать это, поменяем функцию \u003Ccode\u003Einit\u003C\u002Fcode\u003E нашего класса \u003Ccode\u003EApp\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eoverride fun AppState.init() {\n    unwatchedVideos = listOf()\n    watchedVideos = listOf()\n\n    val mainScope = MainScope()\n    mainScope.launch {\n        val videos = fetchVideos()\n        setState {\n            unwatchedVideos = videos\n        }\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЗаметьте, что хотя мы внутри функции \u003Ccode\u003Einit\u003C\u002Fcode\u003E, мы все равно вызываем \u003Ccode\u003EsetState\u003C\u002Fcode\u003E для изменения \u003Ccode\u003EunwatchedVideos\u003C\u002Fcode\u003E внутри корутины. Это происходит из-за того, что наш код неблокирующий, и приложение скорее всего уже отрендерило пустой список, записанный в \u003Ccode\u003EunwatchedVideos\u003C\u002Fcode\u003E изначально. Вызывая \u003Ccode\u003EsetState\u003C\u002Fcode\u003E, мы подскажем рендереру Реакта, что может быть необходима перерисовка.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПо возвращении в браузер мы наконец должны увидеть настоящий список видео:\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe98\u002F63c\u002F4b8\u002Fe9863c4b8f99d4ae60691fbf15bfe1a8.png\" alt=\"real data\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002Fe98\u002F63c\u002F4b8\u002Fe9863c4b8f99d4ae60691fbf15bfe1a8.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа этом часть по разработке в этой практике подошла к концу. Мы прошли долгий путь, от начальной производной \"Hello, World\" до вполне полноценного органайзера видео.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНе отключайтесь, если хотите узнать, как бандлить приложение для использования в продакшене, и как дать приложение в руки пользователям, опубликовав его в облаке.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Estep-07-using-external-rest-api\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Fstep-07-using-external-rest-api\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep9shag-9-deploim-v-prodakshen-i-v-oblakoa\"\u003EШаг 9. Деплоим в продакшен и в облако\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПосле создания приложения хорошо бы его выложить для широкой общественности.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"upakovka-sobrannogo-prilozheniya\"\u003EУпаковка собранного приложения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы упаковать все необходимые файлы приложения для продакшена, достаточно просто запустить Gradle задачу \u003Ccode\u003Ebuild\u003C\u002Fcode\u003E в тул-окне IntelliJ IDEA или с помощью команды \u003Ccode\u003E.\u002Fgradlew build\u003C\u002Fcode\u003E. Она сгенерирует оптимизированный упакованный проект, применяя, например, DCE (dead code elimination – удаление неиспользуемого кода).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНеобходимо подождать, после чего все нужные статические файлы будут созданы в папке \u003Ccode\u003Ebuild\u002Fdistributions\u003C\u002Fcode\u003E. Там будут JS файлы, HTML и другие ресурсы, которые необходимы приложению. Содержимое этой папки готово к деплою, то есть можно, например, положить эти файлы в любой статический HTTP сервер, добавить их на GitHub Pages или захостить на любом облаке.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"deploim-na-heroku\"\u003EДеплоим на Heroku\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EHeroku дает довольно легко развернуть приложение на своем домене. Их бесплатный тариф должен быть достаточен при обучении; его точно хватит, чтобы выложить небольшое приложение и похвастаться перед друзьями и коллегами.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПосле \u003Ca href=\"https:\u002F\u002Fsignup.heroku.com\u002F\" rel=\"nofollow noopener noreferrer\"\u003Eсоздания аккаунта\u003C\u002Fa\u003E и \u003Ca href=\"https:\u002F\u002Fdevcenter.heroku.com\u002Farticles\u002Fheroku-cli\" rel=\"nofollow noopener noreferrer\"\u003Eустановки клиента и входа в него\u003C\u002Fa\u003E мы можем создать git репозиторий и Heroku приложение. Это делается такими командами в терминале:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Egit init\nheroku create\ngit add .\ngit commit -m \"initial commit\"\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ отличие от обычного JVM приложения, которое можно запустить на Heroku (например, написанное на Ktor или Spring Boot), наше приложение генерирует статичные файлы, которые надо раздавать сервером. Поэтому нужно соответствующе настроить Heroku:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Eheroku buildpacks:set heroku\u002Fgradle\nheroku buildpacks:add https:\u002F\u002Fgithub.com\u002Fheroku\u002Fheroku-buildpack-static.git\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EДля выполнения \u003Ccode\u003Eheroku\u002Fgradle\u003C\u002Fcode\u003E необходимо иметь задачу \u003Ccode\u003Estage\u003C\u002Fcode\u003E в Gradle проекте. К счастью, это эквивалент задачи \u003Ccode\u003Ebuild\u003C\u002Fcode\u003E, поэтому очень просто создать еще одну задачу, которая будет вызывать необходимую:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003E\u002F\u002F Heroku Deployment (шаг 9)\ntasks.register(\"stage\") {\n    dependsOn(\"build\")\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕще нужно сконфигурировать \u003Ccode\u003Ebuildpack-static\u003C\u002Fcode\u003E, добавив в проект корневой файл \u003Ccode\u003Estatic.json\u003C\u002Fcode\u003E. Он должен содержать единственное свойство \u003Ccode\u003Eroot\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"json\"\u003E{\n    \"root\": \"build\u002Fdistributions\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТеперь можно вызвать деплой, например, такой последовательностью команд:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"plaintext\"\u003Egit add -A\ngit commit -m \"add stage task and static content root configuration\"\ngit push heroku master\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EЕсли вы пушите не master ветку (а, например, ветку \u003Ccode\u003Estep*\u003C\u002Fcode\u003E из репозитория с состоянием проекта), то нужно поменять команду, чтобы она продолжала пушить в master на Heroku (например, так: \u003Ccode\u003Egit push heroku step-08-deploying-to-production:master\u003C\u002Fcode\u003E).\u003C\u002Fblockquote\u003E\u003Cp\u003EЕсли все прошло по плану, вы увидите ссылку, по которой можно достучаться до нашего приложения во всемирной паутине!\u003Cbr\u002F\u003E\n\u003Cimg src=\"https:\u002F\u002Fhabrastorage.org\u002Fr\u002Fw1560\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F29c\u002F72a\u002Fcaa\u002F29c72acaab8d818c7251d70c01313088.png\" alt=\"heroku\" data-src=\"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fpost_images\u002F29c\u002F72a\u002Fcaa\u002F29c72acaab8d818c7251d70c01313088.png\"\u002F\u003E\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cblockquote\u003EСостояние проекта после выполнения этого шага доступно в ветке \u003Ccode\u003Efinal\u003C\u002Fcode\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fkotlin-hands-on\u002Fweb-app-react-kotlin-js-gradle\u002Ftree\u002Ffinal\" rel=\"nofollow noopener noreferrer\"\u003Eв репозитории\u003C\u002Fa\u003E.\u003C\u002Fblockquote\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep10shag-10-v-dopolnenie-sovremennyy-reakt-s-hukamia\"\u003EШаг 10. В дополнение: современный Реакт с хуками\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли вы прошли всю практику и хотите попробовать еще чего-нибудь крутого, в дополнение расскажем о более современных фичах Реакта.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ React 16.8 появились \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fhooks-intro.html\" rel=\"nofollow noopener noreferrer\"\u003Eхуки\u003C\u002Fa\u003E. Они позволяют использовать состояние и другие возможности Реакта без написания классов для компонентов. Хорошая новость: котлиновские обертки Реакта поддерживают и хуки!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы понять, как устроен этот новый способ написания Реакт компонентов и как эта концепция реализована в Котлине, мы рассмотрим несколько самодостаточных примеров о двух самых используемых встроенных в Реакт хуках – state и effect. \u003Cstrong\u003EКак и другие хуки, эти два используются внутри функциональных компонентов\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"funkcionalnye-komponenty\"\u003EФункциональные компоненты\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИдейно, реактовские функциональные компоненты сами по себе не очень сложны. Они представлены в виде функций, которые содержат инструкции для рендеринга компонента. Свойства для компонента передаются в саму функцию – они не хранятся в \u003Ccode\u003Ethis\u003C\u002Fcode\u003E. Простенький функциональный компонент можно написать на Котлине, например, вот так:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eexternal interface WelcomeProps : RProps {\n    var name: String\n}\n\nval welcome = functionalComponent&lt;WelcomeProps&gt; { props -&gt; \n    h1 {\n        +\"Hello, ${props.name}\"\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКак и для классовых компонентов, мы определяем свойства внутри \u003Ccode\u003Eexternal interface\u003C\u002Fcode\u003E. Тип свойства для функционального компонента мы аналогично определяем в дженерике. Переданная в билдер \u003Ccode\u003EfunctionalComponent\u003C\u002Fcode\u003E функция может напоминать метод \u003Ccode\u003Erender\u003C\u002Fcode\u003E для классовых компонентов.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EИспользовать этот компонент можно как обычно: достаточно передать его внутрь \u003Ccode\u003Echild\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Echild(welcome) {\n    attrs.name = \"Kotlin\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EТакже уже знакомым вам образом можно реализовать более лаконичную обертку:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Efun RBuilder.welcome(handler: WelcomeProps.() -&gt; Unit) = child(welcome) {\n    attrs.handler()\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы проделывали аналогичное действие на шаге 4. После этого для вставки компонента на страницу достаточно написать \u003Ccode\u003Ewelcome { name = \"Kotlin\" }\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКак видите, пока что функциональные компоненты не дают нам чего-то нового. Но их полный потенциал раскрывается при использовании хуков.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"huk-state\"\u003EХук State\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы хранить состояние в функциональном компоненте, можно использовать соответствующий хук. В качестве примера рассмотрим следующую реализацию счетчика:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval counter = functionalComponent&lt;RProps&gt; {\n    val (count, setCount) = useState(0)\n    button {\n        attrs.onClickFunction = { setCount(count + 1) }\n        +\"$count\"\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсть тройка ключевых моментов, которые происходят в примере:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003EuseState\u003C\u002Fcode\u003E вызывается с изначальным значением \u003Ccode\u003E0\u003C\u002Fcode\u003E – поэтому тип этого элемента состояния выводится как \u003Ccode\u003EInt\u003C\u002Fcode\u003E. Также можно указать тип явно, что будет полезно, если придется работать с зануляемым значением (\u003Ccode\u003EuseState&lt;String?&gt;(null)\u003C\u002Fcode\u003E).\u003C\u002Fli\u003E\n\u003Cli\u003EВызов \u003Ccode\u003EuseState\u003C\u002Fcode\u003E возвращает пару, которая сразу же деструктурируется:\u003Cbr\u002F\u003E\n\u003Col\u003E\n\u003Cli\u003EСсылка на текущее состояние (здесь это \u003Ccode\u003Ecount\u003C\u002Fcode\u003E типа \u003Ccode\u003EInt\u003C\u002Fcode\u003E);\u003C\u002Fli\u003E\n\u003Cli\u003EФункция для изменения состояния (здесь это \u003Ccode\u003EsetCount\u003C\u002Fcode\u003E типа \u003Ccode\u003ERSetState&lt;Int&gt; \u002F* = (Int) -&gt; Unit *\u002F\u003C\u002Fcode\u003E).\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EВ отличие от классовых компонентов, изменение состояния не требуется производить внутри \u003Ccode\u003EsetState\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EРеакт заботится о правильном жизненном цикле компонента, поэтому переменная \u003Ccode\u003Ecount\u003C\u002Fcode\u003E будет инициализирована только один раз, а последующие рендеринги будут использовать актуальное состояние. В итоге писать функциональные компоненты несколько проще, чем классовые, так как функциональность получается аналогичной, но код более компактный.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБольше о хуке State можно узнать в \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fhooks-state.html\" rel=\"nofollow noopener noreferrer\"\u003Eофициальной документации\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Cstrong\u003EПримечание от переводчика\u003C\u002Fstrong\u003E: в Котлине также доступна более удобная работа с \u003Ccode\u003EuseState\u003C\u002Fcode\u003E – как с изменяемой переменной-делегатом. Тогда код упрощается, однако, становится менее похожим на традиционный Реакт:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval counter = functionalComponent&lt;RProps&gt; {\n    var count by useState(0)\n    button {\n        attrs.onClickFunction = { ++count }\n        +\"$count\"\n    }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"huk-effect\"\u003EХук Effect\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EХук эффекта приходит на помощь, когда необходимо совершить какое-нибудь побочное действие внутри компонента – такое как вызов API или установление WebSocket соединения. Для демонстрации мы реализовали следующий компонент, который запрашивает случайный факт и по приходе ответа отображает его в теге \u003Ccode\u003Eh3\u003C\u002Fcode\u003E:\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cpre\u003E\u003Ccode class=\"kotlin\"\u003Eval randomFact = functionalComponent&lt;RProps&gt; {\n    val (randomFact, setRandomFact) = useState&lt;String?&gt;(null)\n    useEffect(emptyList()) {\n        GlobalScope.launch {\n            val fortyTwoFact = window.fetch(\"http:\u002F\u002Fnumbersapi.com\u002F42\").await().text().await()\n            setRandomFact(fortyTwoFact)\n        }\n    }\n    h3 { +(randomFact ?: \"Fetching...\") }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЧтобы следить за результатом запроса, мы используем хук состояния, почти такой же, как в предыдущем параграфе. Сам запрос мы совершаем внутри \u003Ccode\u003EuseEffect\u003C\u002Fcode\u003E, где при получении результата вызываем \u003Ccode\u003EsetRandomFact\u003C\u002Fcode\u003E для сохранения этого текста в состоянии.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЗаметьте, что \u003Ccode\u003EuseEffect\u003C\u002Fcode\u003E вызывается с двумя параматрами. Второй – это функция, а первый – \u003Cem\u003Eзависимости\u003C\u002Fem\u003E эффекта. Зависимости определяют, какие свойства и состояния должны измениться, чтобы запустить переданную в \u003Ccode\u003EuseEffect\u003C\u002Fcode\u003E функцию вновь. В нашем случае мы хотим сделать только один запрос к API независимо от других событий в приложении. Поэтому мы передаем пустой список в качестве зависимостей.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли же не передавать пустой список, то в таком случае хук эффекта будет вызываться после каждого вызова \u003Ccode\u003EsetRandomFact\u003C\u002Fcode\u003E, так что получится бесконечный цикл.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБольше об этих и других тонкостях хука Effect, а также о его соотнесении с \"классическим\" жизненным циклом в Реакте, можно опять же узнать в \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fhooks-effect.html\" rel=\"nofollow noopener noreferrer\"\u003Eофициальной документации\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"domashnee-zadanie\"\u003EДомашнее задание\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЕсли хотите, можете конвертировать какие-нибудь компоненты нашего приложения, например, \u003Ccode\u003EvideoList\u003C\u002Fcode\u003E, в функциональные компоненты с хуками. Хук \u003Ccode\u003EuseState\u003C\u002Fcode\u003E пригодится в большинстве компонентов, а вот \u003Ccode\u003EuseEffect\u003C\u002Fcode\u003E будет важен при общении с внешним API, которое мы сделали на шаге 8.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКлассовые и функциональные компоненты могут жить припеваючи в одном Реакт приложении, поэтому вы можете просто добавить \u003Cem\u003Eновый\u003C\u002Fem\u003E функциональный компонент в наше приложение.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"a-namestep11shag-11-chto-dalshea\"\u003EШаг 11. Что дальше?\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dopolnitelnye-fichi-prilozheniya\"\u003EДополнительные фичи приложения\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EКонечно же, сделанное нами приложение далеко не идеально. Однако этот результат вы можете использовать как стартовую точку для изучения дальнейших тем в сфере Реакта, Kotlin\u002FJS и других близких технологий.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"poisk\"\u003EПоиск\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EБыло бы отлично иметь возможность фильтровать список видео по заголовку или докладчику. Для этого хорошо подойдет поисковая строка, которую можно реализовать в качестве дополнительного функционала. Вы можете изучить, как \u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fforms.html\" rel=\"nofollow noopener noreferrer\"\u003Eпредлагается работать с HTML формами в Реакте\u003C\u002Fa\u003E, и сразу же применить полученные знания на практике.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"persistentnost\"\u003EПерсистентность\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНаше приложение теряет состояние просмотренного контента каждый раз при перезагрузке страницы. Возможно, настало время сделать бэк-энд. Познакомьтесь с каким-нибудь веб фреймворком, поддерживаемым Котлином (таким как \u003Ca href=\"https:\u002F\u002Fktor.io\u002F\" rel=\"nofollow noopener noreferrer\"\u003EKtor\u003C\u002Fa\u003E), и попробуйте написать сервер для нашего приложения, который будет сохранять список просмотренных и непросмотренных видео. Или же можно обойтись без бэк-энда и \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FWindow\u002FlocalStorage\" rel=\"nofollow noopener noreferrer\"\u003Eсохранять информацию прямо на клиенте\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch4 id=\"slozhnye-apis\"\u003EСложные APIs\u003C\u002Fh4\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ прекрасном мире веба есть множество датасетов и APIs, с которыми можно поиграться. Почему бы не создать фотогалерею для \u003Ca href=\"https:\u002F\u002Fthecatapi.com\u002F\" rel=\"nofollow noopener noreferrer\"\u003Eфоток котеек\u003C\u002Fa\u003E? Или разукрасить свою жизнь с помощью \u003Ca href=\"https:\u002F\u002Funsplash.com\u002Fdevelopers\" rel=\"nofollow noopener noreferrer\"\u003Eбесплатного сервиса с разнообразными фотографиями\u003C\u002Fa\u003E (\u003Cstrong\u003Eпримечание переводчика\u003C\u002Fstrong\u003E: не забудьте обратить внимание на \u003Ca href=\"https:\u002F\u002Funsplash.com\u002Flicense\" rel=\"nofollow noopener noreferrer\"\u003Eлицензию\u003C\u002Fa\u003E)? Количество данных, которые можно затащить в свое приложение, просто неисчислимо!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"stili-poluchshe-otzyvchivost-i-setki\"\u003EСтили получше: отзывчивость и сетки\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EНа данный момент наше приложение в экстремальных ситуациях выглядит кривовато, например, в узких окнах и на экранах смартфонов. Как раз можно изучить CSS сетки (grids) и сделать приложение отзывчивым к размерам страницы (бонусная задачка: не использовать медиавыражения).\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"drugie-biblioteki\"\u003EДругие библиотеки\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВ репозитории \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\" rel=\"nofollow noopener noreferrer\"\u003Ekotlin-wrappers\u003C\u002Fa\u003E можно найти больше официальных котлиновских оберток для разных JS библиотек, а также первоначальную информацию по их использованию. Например (но не ограничиваясь):\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\u002Ftree\u002Fmaster\u002Fkotlin-react-redux\" rel=\"nofollow noopener noreferrer\"\u003EReact-Redux\u003C\u002Fa\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FJetBrains\u002Fkotlin-wrappers\u002Ftree\u002Fmaster\u002Fkotlin-react-router-dom\" rel=\"nofollow noopener noreferrer\"\u003EReact-Router-DOM\u003C\u002Fa\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"soobschestvo-pomosch-i-reshenie-problem\"\u003EСообщество, помощь и решение проблем\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EЛучший способ получить помощь по созданию Реакт приложений на Котлине – посетить \u003Ca href=\"https:\u002F\u002Fyoutrack.jetbrains.com\u002Fissues\u002FCRKA\" rel=\"nofollow noopener noreferrer\"\u003EYouTrack\u003C\u002Fa\u003E. Если вы не можете найти вашу проблему, не бойтесь создать еще один тикет. Также можно присоединиться к \u003Ca href=\"https:\u002F\u002Fsurveys.jetbrains.com\u002Fs3\u002Fkotlin-slack-sign-up\" rel=\"nofollow noopener noreferrer\"\u003Eофициальному котлиновскому Slack\u003C\u002Fa\u003E. Там есть много каналов, включая \u003Ccode\u003E#javascript\u003C\u002Fcode\u003E и \u003Ccode\u003E#react\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dalneyshee-izuchenie-korutin\"\u003EДальнейшее изучение корутин\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EМы совсем чуть-чуть потрогали мощные концепции корутин, которые стоит использовать во многих приложениях. Если вам интересно узнать больше о написании конкурентного кода, предлагаем начать с \u003Ca href=\"https:\u002F\u002Fplay.kotlinlang.org\u002Fhands-on\u002FIntroduction%20to%20Coroutines%20and%20Channels\u002F01_Introduction\" rel=\"nofollow noopener noreferrer\"\u003Eпрактики по корутинам\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch3 id=\"dalneyshee-izuchenie-reakta\"\u003EДальнейшее изучение Реакта\u003C\u002Fh3\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002F\" rel=\"nofollow noopener noreferrer\"\u003EОфициальная документация по Реакту\u003C\u002Fa\u003E написана довольно исчерпывающе и вообще хорошо. Вы теперь знаете базовые идеи Реакта и их использование из Котлина, поэтому надеемся, что вы сможете разобраться с остальными концепциями из официальной документации и перевести их на Котлин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EВозможно, в будущем вы даже станете профессионалом котлиновского Реакта!\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Ch2 id=\"posleslovie-ot-perevodchika\"\u003EПослесловие от переводчика\u003C\u002Fh2\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EСпасибо, что дошли до конца! Если вы оценили Kotlin\u002FJS и планируете продолжать его изучение, следующим шагом я бы порекомендовал научиться читать JS, а в особенности JSX – примеры по Реакту используют именно это, поэтому нужно понимать, как переписывать их на Котлин.\u003C\u002Fp\u003E\u003Cbr\u002F\u003E\n\u003Cp\u003EПредрекая вопросы, расскажу, почему я сам сделал выбор в пользу Kotlin DSL. В отличие от отдельно придуманного синтаксиса JSX со своими особенностями, Kotlin DSL довольно привычен и интуитивен для тех, кто уже работал с Котлином. Здесь, как говорилось, можно использовать обычные котлиновские конструкции вроде циклов, а для подключения Реакта к своему проекту достаточно подключить библиотеку – настраивать компиляцию не надо. В общем, на Котлине писать выходит более комфортно, хотя и все еще менее производительно. С нетерпением жду развития Kotlin\u002FJS и сообщества вокруг него!\u003C\u002Fp\u003E\u003C\u002Fdiv\u003E","tags":[{"titleHtml":"javascript"},{"titleHtml":"reactjs"},{"titleHtml":"kotlin"}],"metadata":{"stylesUrls":[],"scriptUrls":[],"shareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F555744\u002Fe77692b1636232590f60dbc7b84ae70f\u002F","shareImageWidth":1200,"shareImageHeight":630,"vkShareImageUrl":"https:\u002F\u002Fhabr.com\u002Fshare\u002Fpublication\u002F555744\u002Fe77692b1636232590f60dbc7b84ae70f\u002F?format=vk","schemaJsonLd":"{\"@context\":\"http:\\\u002F\\\u002Fschema.org\",\"@type\":\"Article\",\"mainEntityOfPage\":{\"@type\":\"WebPage\",\"@id\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Farticles\\\u002F555744\\\u002F\"},\"headline\":\"Практика по Котлину: Создание веб приложений на React и Kotlin\\\u002FJS\",\"datePublished\":\"2021-05-04T19:37:44+03:00\",\"dateModified\":\"2021-05-04T20:55:46+03:00\",\"author\":{\"@type\":\"Person\",\"name\":\"SerVB\"},\"publisher\":{\"@type\":\"Organization\",\"name\":\"Habr\",\"logo\":{\"@type\":\"ImageObject\",\"url\":\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fwebt\\\u002Fa_\\\u002Flk\\\u002F9m\\\u002Fa_lk9mjkccjox-zccjrpfolmkmq.png\"}},\"description\":\"От переводчика. Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерж...\",\"url\":\"https:\\\u002F\\\u002Fhabr.com\\\u002Fru\\\u002Farticles\\\u002F555744\\\u002F#post-content-body\",\"about\":[\"h_javascript\",\"h_kotlin\",\"h_reactjs\",\"h_web_design\",\"h_webdev\",\"f_develop\",\"f_design\"],\"image\":[\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fe82\\\u002F357\\\u002Fada\\\u002Fe82357ada36198277e49b1ad14a830bc.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fe98\\\u002F63c\\\u002F4b8\\\u002Fe9863c4b8f99d4ae60691fbf15bfe1a8.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F897\\\u002F290\\\u002F973\\\u002F897290973b762d0318e9a62b3971a221.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fdc2\\\u002F12f\\\u002F22f\\\u002Fdc212f22f7b4bd36e6d18600f87ef77a.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F81c\\\u002Fa95\\\u002F32c\\\u002F81ca9532c243740abf29334207164d52.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F275\\\u002F194\\\u002F45d\\\u002F27519445d08e39e965416a2db3c07892.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fada\\\u002F0a2\\\u002F550\\\u002Fada0a25506506187b003da6597154be9.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Faff\\\u002F20b\\\u002F47c\\\u002Faff20b47c153c8002fea293f13976a4b.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Ff70\\\u002F411\\\u002F691\\\u002Ff70411691aa04c00591ceefbeda5b3d9.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002Fa5f\\\u002Fb36\\\u002Fef7\\\u002Fa5fb36ef7172f53642a2e5364fb19319.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F07f\\\u002F85e\\\u002F867\\\u002F07f85e8677b33e952fdc2734aee60e95.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F188\\\u002F255\\\u002F3e3\\\u002F1882553e39a1d6e05dc7f3b637e2bb9d.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F1b8\\\u002F38d\\\u002F927\\\u002F1b838d92717d355eb47cdc830848afad.png\",\"https:\\\u002F\\\u002Fhabrastorage.org\\\u002Fgetpro\\\u002Fhabr\\\u002Fpost_images\\\u002F29c\\\u002F72a\\\u002Fcaa\\\u002F29c72acaab8d818c7251d70c01313088.png\"]}","metaDescription":"От переводчика . Привет! Про Kotlin есть стереотип, будто бы это язык для разработки только под Android. На самом деле, это совсем не так: язык официально поддерживает несколько платформ ( JVM , JS ,...","mainImageUrl":null,"amp":false,"customTrackerLinks":[]},"polls":[{"id":"34804","timeElapsed":null,"answersType":"radio","votesCount":40,"passCount":8,"textHtml":"Как вам идея таких переводов в целом и в частности?","relatedData":null,"variants":[{"id":"164974","textHtml":"Переводы английских туториалов на русский нужны; этот перевод неплохой, продолжай писать подобное.","votesCount":30,"percent":75,"selected":false},{"id":"164976","textHtml":"Переводы туториалов нужны, но качество этого перевода низкое.","votesCount":1,"percent":2.5,"selected":false},{"id":"164978","textHtml":"Переводы туториалов не нужны: лучше сразу в оригинале читать. Но этот перевод хороший.","votesCount":7,"percent":17.5,"selected":false},{"id":"164980","textHtml":"Переводы туториалов не нужны, а переводчик этого туториала зря потратил время.","votesCount":1,"percent":2.5,"selected":false},{"id":"164982","textHtml":"Другое мнение (в комментариях\u002Fв личке\u002Fпри себе).","votesCount":1,"percent":2.5,"selected":false}]}],"commentsEnabled":{"status":true,"reason":null},"rulesRemindEnabled":false,"votesEnabled":true,"status":"published","plannedPublishTime":null,"checked":null,"hasPinnedComments":false,"format":"tutorial","banner":null,"multiwidget":null,"multiwidgetUuid":null,"readingTime":38,"complexity":null,"isEditorial":false}},"articlesIds":{},"isLoading":false,"pagesCount":{},"route":{},"reasonsList":null,"postReasonsList":null,"view":"list","lastVisitedRoute":{},"ssrCommentsArticleIds":[""],"viewedPosts":[],"myFeedFilter":{"complexity":"all","score":"all","types":["articles","posts","news"]},"myFeedIsApplyFilters":false,"myFeedIsForce":false,"karma":{"userReasonsList":null}},"authorContribution":{"authors":{}},"betaTest":{"currentAnnouncement":null,"announcements":{},"announcementCards":null,"announcementComments":{},"announcementCommentThreads":{},"announcementCommentingStatuses":{},"archivedList":[]},"authorStatistics":{"articleRefs":{},"articleIds":{},"pagesCount":{},"route":{},"viewsCount":[],"maxStatsCount":{}},"career":{"seoLandings":[{"title":"React разработчик","vacanciesCount":48,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Freact_razrabotchik","itemHubs":["javascript","reactjs"]},{"title":"JavaScript разработчик","vacanciesCount":131,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fprogrammist_javascript","itemHubs":["javascript","nodejs","angular","reactjs","vuejs","typescript","sveltejs"]},{"title":"Веб дизайнер","vacanciesCount":24,"itemUrl":"https:\u002F\u002Fcareer.habr.com\u002Fvacancies\u002Fveb_dizajner","itemHubs":["design","web_design"]}],"hubs":"javascript,kotlin,reactjs,web_design,webdev"},"comments":{"articleComments":{},"articlePinnedComments":{},"searchCommentsResults":null,"pagesCount":null,"commentAccess":{},"scrollParents":{},"pageArticleComments":{"lastViewedComment":0,"postId":null,"lastCommentTimestamp":"","moderated":[],"moderatedIds":[],"commentRoute":"","idempotenceKey":""}},"companies":{"companyRefs":{},"companyIds":{},"companyTopIds":{},"pagesCount":{},"companyProfiles":{},"companiesCategories":[],"companiesCategoriesTotalCount":0,"companiesWidgets":{},"companiesWorkers":{},"companiesFans":{},"multiwidgets":{},"route":{},"isLoading":false,"companyWorkersLoading":false,"companyFansLoading":false,"multiwidgetLoading":false,"vacancies":{},"companiesGalleries":{},"companiesBanners":{},"companiesLandingVacancies":{},"companiesTechnologies":{},"workplaceInfo":null},"companyAdmin":{"companyInfo":null,"companyInfoLoading":false,"faqArticles":null,"brandingPreviewImageUrl":null,"jivoStatus":0,"adminNotifications":null,"availableInvitesCount":{}},"companyAdd":{"currentStep":"","stepsData":{},"uncompletedSteps":[],"isStepLoading":true,"isStepCommitting":false,"isInitialized":false,"agreementContent":""},"companiesContribution":{"hubs":{},"flows":{},"companyRefs":{}},"companyHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"conversation":{"messages":[],"respondent":null,"isLoadMore":false},"conversations":{"conversations":[],"pagesCount":0},"docs":{"menu":{},"articles":{},"mainMenu":[],"loading":{"main":false,"dropdown":false,"article":false}},"feature":{"isProbablyVisible":true},"fixedBanner":{"isArticleStickyPanelVisible":false,"isArticleStickyPanelAtTheBottom":false,"isFixedBannerVisible":false,"isStickyPanelIconsHidden":false},"flows":{"flows":[{"id":"1","alias":"develop","title":"Разработка","titleHtml":"Разработка","route":{"name":"FLOW_PAGE","params":{"flowName":"develop"}}},{"id":"6","alias":"admin","title":"Администрирование","titleHtml":"Администрирование","route":{"name":"FLOW_PAGE","params":{"flowName":"admin"}}},{"id":"2","alias":"design","title":"Дизайн","titleHtml":"Дизайн","route":{"name":"FLOW_PAGE","params":{"flowName":"design"}}},{"id":"3","alias":"management","title":"Менеджмент","titleHtml":"Менеджмент","route":{"name":"FLOW_PAGE","params":{"flowName":"management"}}},{"id":"4","alias":"marketing","title":"Маркетинг","titleHtml":"Маркетинг","route":{"name":"FLOW_PAGE","params":{"flowName":"marketing"}}},{"id":"7","alias":"popsci","title":"Научпоп","titleHtml":"Научпоп","route":{"name":"FLOW_PAGE","params":{"flowName":"popsci"}}}],"updates":{}},"global":{"isPwa":false,"device":"mobile","isHabrCom":true,"requestId":"80a986efbabc5494486c92112a653b1e"},"hubs":{"hubRefs":{},"hubIds":{},"pagesCount":{},"isLoading":false,"route":{}},"hubsBlock":{"hubRefs":{},"hubIds":{}},"i18n":{"fl":"ru","hl":"ru"},"info":{"welcomePage":{},"isLoading":true},"location":{"urlStruct":{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"query":{},"pathname":"\u002Fru\u002Farticles\u002F555744\u002F","path":"\u002Fru\u002Farticles\u002F555744\u002F","href":"\u002Fru\u002Farticles\u002F555744\u002F"}},"me":{"user":null,"uuid":null,"ppgDemanded":false,"karmaResetInfo":{"canReincarnate":null,"wasReincarnated":null,"currentScore":null},"notes":null,"userUpdates":{"feeds":{"newPostsCount":null,"newThreadsCount":null,"newNewsCount":null,"newCount":null},"conversationUnreadCount":0}},"mostReadingList":{"mostReadingListIds":[],"mostReadingListRefs":null,"promoPost":null},"onboarding":{"currentStep":null,"stepsData":{},"stepsErrors":{},"completedSteps":[],"isStepCommitting":false,"isCommitDisabled":true},"ppa":{"articles":{},"card":null,"transactions":null,"totalTransactions":null,"isAccessible":null},"projectsBlocks":{"activeBlocks":{"salary":"project-block-article"}},"promoData":{"isLoading":false,"hasLoaded":false,"featurer":null,"megaposts":null,"promoLinks":null,"promoPosts":null,"sticker":null},"publicationStatistics":{"statsInfo":{},"statsFunnels":{},"statsGraph":{},"defaultSuggest":{},"suggest":{},"timeTracker":{},"isTrackingActivity":false,"isUserActive":true,"otherPublicationStats":{}},"pullRefresh":{"shouldRefresh":false},"sandbox":{"articleIds":[],"articleRefs":{},"pagesCount":null,"route":{},"lastVisitedRoute":{},"isLoading":false},"search":{"searchQueryError":null},"settingsOther":{"inputs":{"uiLang":{"errors":[],"ref":null,"value":""},"articlesLangEnglish":{"errors":[],"ref":null,"value":false},"articlesLangRussian":{"errors":[],"ref":null,"value":false},"agreement":{"errors":[],"ref":null,"value":false},"email":{"errors":[],"ref":null,"value":true},"digest":{"errors":[],"ref":null,"value":true}}},"similarList":{"similarListIds":[],"similarListRefs":null},"ssr":{"error":null,"isDataLoaded":true,"isDataLoading":false,"isHydrationFailed":false,"isServer":false},"stories":{"stories":[{"id":"story-998","author":{"logo":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F91a\u002F166\u002F49f\u002F91a16649f9ef89302a5a56cfa22a451d.png","title":"Яндекс Практикум","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up"},"title":"Как расти на работе?","lang":"ru","startTime":"2025-03-18T18:45:00+03:00","finishTime":"2025-03-31T19:00:00+03:00","slides":[{"id":"story-998_1","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fbf4\u002F911\u002F7e6\u002Fbf49117e637ff2099b3944f8803cd7a3.png","button":null},{"id":"story-998_2","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3e3\u002Fc84\u002Fe83\u002F3e3c84e8330ea1ddf72e9d310457ed2f.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_3","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F84b\u002F533\u002F3c3\u002F84b5333c3e77e8dac62a8b50d042acb9.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_4","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F257\u002Feb0\u002F2be\u002F257eb02bea1777e13f3e647cae6e06cd.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_5","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F858\u002F086\u002F0ed\u002F8580860ed3497c043c04f9a42054d74f.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_6","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcdf\u002F32f\u002F387\u002Fcdf32f38777f046c063b5182f4125e14.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_7","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fd48\u002Ff2d\u002F0e2\u002Fd48f2d0e2ecd7d746d738191bb913d8f.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_8","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb38\u002Ffd7\u002Fee0\u002Fb38fd7ee04848bf3b058be7403438bd1.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_9","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F79e\u002Feaa\u002F9d8\u002F79eeaa9d8af5a288ad42bd9d63b5793a.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}},{"id":"story-998_10","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcdc\u002F17e\u002F385\u002Fcdc17e38582dc67838b9abfb200d982e.png","button":{"title":"Расти в карьере","link":"https:\u002F\u002Fu.habr.com\u002Fstories_up","colorType":"light"}}]},{"id":"story-996","author":{"logo":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fe63\u002F36d\u002Fa24\u002Fe6336da24460ab6b9fbc347d03eb263a.png","title":"Хабр","link":null},"title":"Здоровье айтишника","lang":"ru","startTime":"2025-03-17T10:22:00+03:00","finishTime":"2025-04-13T10:22:00+03:00","slides":[{"id":"story-996_1","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb7c\u002F6de\u002F8ea\u002Fb7c6de8ea6789dbc30f071716172b6dd.jpg","button":null},{"id":"story-996_2","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2e7\u002F88a\u002F0fe\u002F2e788a0fe61729ca8b23eb59069c844f.jpg","button":{"title":"Личный опыт","link":"https:\u002F\u002Fu.habr.com\u002Fzd-1","colorType":"light"}},{"id":"story-996_3","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb93\u002F6f4\u002F256\u002Fb936f425653b84fa60ab00d09f78c543.jpg","button":{"title":"Как это было","link":"https:\u002F\u002Fu.habr.com\u002Fzd-2","colorType":"light"}},{"id":"story-996_4","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc10\u002Fd14\u002Ff5a\u002Fc10d14f5a4859fe10baecbcc2bcb8828.jpg","button":{"title":"Шея в фокусе","link":"https:\u002F\u002Fu.habr.com\u002Fzd-3","colorType":"dark"}},{"id":"story-996_5","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F535\u002Fe1b\u002F77a\u002F535e1b77a9eb896262ad73321f2ad99f.jpg","button":{"title":"Фотоинструкция","link":"https:\u002F\u002Fu.habr.com\u002Fzd-4","colorType":"light"}},{"id":"story-996_6","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F569\u002Fc39\u002F49f\u002F569c3949f5b330ea85d4a1864f481c3d.jpg","button":{"title":"Сидите (не)правильно","link":"https:\u002F\u002Fu.habr.com\u002Fzd-5","colorType":"dark"}},{"id":"story-996_7","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1f2\u002F1de\u002Fdbf\u002F1f21dedbf2902bc4061a75b839b63595.jpg","button":{"title":"Журнал изменений","link":"https:\u002F\u002Fu.habr.com\u002Fzd-6","colorType":"dark"}},{"id":"story-996_8","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F95a\u002F164\u002F21b\u002F95a16421badc3a9f1135309ab0c42c41.jpg","button":{"title":"Альтернатива","link":"https:\u002F\u002Fu.habr.com\u002Fzd-7","colorType":"light"}},{"id":"story-996_9","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F624\u002F027\u002F54d\u002F62402754d311798af44bcfe7f9abfedc.jpg","button":{"title":"Хроника поисков","link":"https:\u002F\u002Fu.habr.com\u002Fzd-8","colorType":"dark"}}]},{"id":"story-992","author":{"logo":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3fe\u002F2fc\u002Fb05\u002F3fe2fcb05df852d7e1e00d44e54e39ae.png","title":"Сезоны Хабра","link":"https:\u002F\u002Fu.habr.com\u002Ffnstories"},"title":"Угадайте будущее в новом сезоне","lang":"ru","startTime":"2025-03-12T19:15:00+03:00","finishTime":"2025-03-31T23:56:00+03:00","slides":[{"id":"story-992_1","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc56\u002Faf5\u002Fc43\u002Fc56af5c4377f7f7b94f7b6ad20fc92c3.png","button":{"title":"А что за сезон?","link":"https:\u002F\u002Fu.habr.com\u002Ffnstories","colorType":"light"}},{"id":"story-992_2","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8fa\u002Fde7\u002F65d\u002F8fade765d99207f31c597283ae6ce912.png","button":{"title":"Какие темы нужны","link":"https:\u002F\u002Fu.habr.com\u002Ffnstories","colorType":"dark"}},{"id":"story-992_3","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F23e\u002F7b9\u002Fb24\u002F23e7b9b24cb056d1a42e8d31ccea16ce.png","button":{"title":"Сезон будущего ИИ","link":"https:\u002F\u002Fu.habr.com\u002Ffnstories","colorType":"dark"}},{"id":"story-992_4","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F27b\u002Fbfc\u002Fa18\u002F27bbfca18e656ee0122b5cb8eb2cb502.png","button":{"title":"Все правила сезона","link":"https:\u002F\u002Fu.habr.com\u002Ffnstories","colorType":"dark"}},{"id":"story-992_5","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F1e0\u002F6c6\u002Ff33\u002F1e06c6f33e703bbd2b2ae3baee3376fd.png","button":{"title":"Как участвовать","link":"https:\u002F\u002Fu.habr.com\u002Ffnstories","colorType":"dark"}}]},{"id":"story-990","author":{"logo":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F282\u002Fe80\u002Fbf1\u002F282e80bf1b73484126ed53c6f3e42692.png","title":"Aeza","link":"https:\u002F\u002Fu.habr.com\u002FI72qi"},"title":"С праздником весны!","lang":"ru","startTime":"2025-03-09T10:15:00+03:00","finishTime":"2025-03-30T23:59:00+03:00","slides":[{"id":"story-990_1","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F064\u002F9dd\u002Ff59\u002F0649ddf5949cae6c9342fb62034a36ac.png","button":null},{"id":"story-990_2","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F05f\u002F96b\u002F25e\u002F05f96b25e910c32256ee0b1916f21380.png","button":{"title":"Семейная история","link":"https:\u002F\u002Fu.habr.com\u002Fey2bY","colorType":"light"}},{"id":"story-990_3","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fcd1\u002Ff5d\u002F921\u002Fcd1f5d921bb9489ac11727272660bdb6.png","button":{"title":"Движущиеся картинки","link":"https:\u002F\u002Fu.habr.com\u002FWLKXU","colorType":"light"}},{"id":"story-990_4","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb55\u002Fd45\u002Fec5\u002Fb55d45ec50e53275c60d16ea886a0672.png","button":{"title":"Личный опыт","link":"https:\u002F\u002Fu.habr.com\u002FSxrki","colorType":"light"}},{"id":"story-990_5","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ffa7\u002F1ce\u002Ffca\u002Ffa71cefca5ed0a3fe8b50bd703b3605f.png","button":{"title":"Алгоритм","link":"https:\u002F\u002Fu.habr.com\u002Ftbz2p","colorType":"light"}},{"id":"story-990_6","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F435\u002F89d\u002Ff90\u002F43589df9018846cc6a8eed986226b252.png","button":{"title":"Выбрать сценарий","link":"https:\u002F\u002Fu.habr.com\u002F0RCPk","colorType":"light"}},{"id":"story-990_7","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F514\u002F5f8\u002F619\u002F5145f86194ad48dad48a846b42af0f93.png","button":{"title":"Jiraзамещение","link":"https:\u002F\u002Fu.habr.com\u002FEwhYq","colorType":"light"}},{"id":"story-990_8","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F439\u002Fa83\u002Fae7\u002F439a83ae78f7ef711e3b9bbed1ec26c5.png","button":{"title":"8 вещей","link":"https:\u002F\u002Fu.habr.com\u002FVTv2r","colorType":"light"}},{"id":"story-990_9","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F02d\u002F783\u002F2f7\u002F02d7832f7b1c95d88bff9f34209e204a.png","button":{"title":"Интерфейсы","link":"https:\u002F\u002Fu.habr.com\u002FUFOMZ","colorType":"light"}},{"id":"story-990_10","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0cb\u002Ff7f\u002F0d9\u002F0cbf7f0d905d486ce4ff82bc939b21d5.png","button":{"title":"Стикеры ваши","link":"https:\u002F\u002Fu.habr.com\u002FoA1K7","colorType":"light"}}]},{"id":"story-984","author":{"logo":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F648\u002F61b\u002F9ae\u002F64861b9aecb7c474cd94063f98045541.png","title":"Хабр","link":null},"title":"Всегда котов!","lang":"ru","startTime":"2025-03-01T00:01:09+03:00","finishTime":"2025-03-23T16:21:00+03:00","slides":[{"id":"story-984_1","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fc06\u002Fc21\u002F93f\u002Fc06c2193ff34362ac2af782cf2571f55.png","button":null},{"id":"story-984_2","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb68\u002F15f\u002F763\u002Fb6815f7630b9c015b1e67efb5bdf12d4.jpg","button":{"title":"Сделать purrrr","link":"https:\u002F\u002Fu.habr.com\u002Fj4DN1","colorType":"light"}},{"id":"story-984_3","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F550\u002F76e\u002Fd7a\u002F55076ed7a0954e243f944fc2f330623a.png","button":{"title":"Тыгыдык","link":"https:\u002F\u002Fu.habr.com\u002Fya360_kotov","colorType":"dark"}},{"id":"story-984_4","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2fb\u002F23b\u002F06c\u002F2fb23b06cf294c2050104b2aef589788.jpg","button":{"title":"Исследование","link":"https:\u002F\u002Fu.habr.com\u002FbO3r0","colorType":"light"}},{"id":"story-984_5","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff50\u002F50f\u002F0ae\u002Ff5050f0aeea1335c4f0544c1863f8342.jpg","button":{"title":"Детали проекта","link":"https:\u002F\u002Fu.habr.com\u002FQJmhe","colorType":"light"}},{"id":"story-984_6","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F825\u002F3dd\u002F5f5\u002F8253dd5f5c19dd061578f1d09310a45f.jpg","button":{"title":"Эксперименты","link":"https:\u002F\u002Fu.habr.com\u002FVaOdo","colorType":"light"}},{"id":"story-984_7","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F3fb\u002Fc92\u002F0f9\u002F3fbc920f9ea81eca2c1c027ff77fc659.jpg","button":{"title":"Это не мем","link":"https:\u002F\u002Fu.habr.com\u002F0Wb3p","colorType":"light"}},{"id":"story-984_8","image":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F2b4\u002F794\u002Fc33\u002F2b4794c33844e60aad9468018fd132cd.jpg","button":{"title":"В засаде","link":"https:\u002F\u002Fu.habr.com\u002FnasCD","colorType":"dark"}}]}]},"technotext":{"years":[],"technotextDocForNominees":null,"technotextDocForWinners":null,"technotextInfo":{},"technotextInfoLoading":false,"technotextWinners":{},"technotextWinnersLoading":false},"userHubsContribution":{"contributionRefs":{"hubRefs":{},"hubIds":{}}},"userInvites":{"availableInvites":0,"usedInvitesIds":[],"usedInvitesRefs":{},"usedInvitesPagesCount":0,"unusedInvitesIds":[],"unusedInvitesRefs":{},"unusedInvitesPagesCount":0},"userVotes":{"karmaVotesList":[],"karmaVotesPagesCount":null,"karmaVotesListLoading":false,"commentsVotesList":[],"commentsVotesPagesCount":null,"commentsVotesListLoading":false,"postsVotesList":[],"postsVotesPagesCount":null,"postsVotesListLoading":false,"userVotesList":[],"userVotesPagesCount":null,"userVotesListLoading":false},"users":{"authorRefs":{},"authorIds":{},"pagesCount":{},"authorProfiles":{"servb":{"alias":"SerVB","badgets":[{"title":"Захабренный","description":"Пользователь с кармой \u003E0","url":null,"isRemovable":false},{"title":"Бета-тестер","description":"Участвует в тестировании новой функциональности","url":"https:\u002F\u002Fhabr.com\u002Fbeta\u002Fwelcome\u002F","isRemovable":false}],"aboutHtml":"","contacts":[],"invitedBy":{"issuerLogin":"habrahabr","timeCreated":"2017-12-25T17:11:43+00:00"},"careerProfile":null,"companies":{"pagesCount":1,"companyIds":[],"companyRefs":{}}}},"userHubs":{},"userInvitations":{},"authorFollowers":{},"authorFollowed":{},"userSpecialization":{},"karmaStats":[],"statistics":null,"isLoading":false,"authorFollowersLoading":false,"authorFollowedLoading":false,"userHubsLoading":false,"userInvitationsLoading":false,"route":{}},"viewport":{"prevScrollY":{},"scrollY":0,"width":0},"tracker":{"notificationsLoading":false,"notificationsList":[],"notificationsPageCount":0,"pendingMarkNotificationsRead":[],"publicationsLoading":true,"publicationsList":[],"publicationsPageCount":0,"pendingDeletePublications":false,"pendingMarkPublicationsRead":false},"events":{"eventRefs":{},"eventIds":[],"pagesCount":0,"categories":[],"cities":[],"actualEvents":[{"id":"588","titleHtml":"Конкурс «Снежный код» от Хекслета. Три гранта на бесплатное 10-месячное обучение","descriptionHtml":"\u003Cp\u003EУчаствуйте в конкурсе грантов от онлайн-школы программирования Хекслет. Три победителя пройдут 10-месячное обучение с наставником, освоив один из востребованных стеков: Java, Python, JavaScript, PHP или Node.js.\u003C\u002Fp\u003E\u003Cp\u003EЭто шанс без вложений освоить новый стек, систематизировать знания, восполнить пробелы и повысить свою ценность на рынке. Технологии развиваются быстро — обновляйте навыки, чтобы не отставать.\u003C\u002Fp\u003E\u003Cp\u003EПомимо грантов, можно выиграть доступ ко всем курсам Хекслета, полезные подписки, сертификаты и подарки от Хабра и партнеров.\u003C\u002Fp\u003E\u003Cp\u003EВ прошлом году три победителя успешно завершили программу и уже работают в IT.  Инвестируйте время в свое развитие — участвуйте! \u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff79\u002F1fc\u002F79d\u002Ff791fc79d0d9fdda84397ed0c0717764.png","eventUrl":"https:\u002F\u002Fspecial.hexlet.io\u002Fgrant?utm_source=partners&utm_medium=referral&utm_campaign=grant&utm_content=link&utm_term=placement_habr","startDay":"2025-02-17","finishDay":"2025-03-24","isOnline":true,"geo":[],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"}],"tags":["гранты","конкурс","Хекслет","Java","Python","JavaScript","PHP","Node.js"],"metadata":null},{"id":"596","titleHtml":"Офлайн-конференция Хабр х K-team: как удерживать таланты в 2025 году","descriptionHtml":"\u003Cp\u003EМы — Хабр и K-Team — провели масштабное исследование, чтобы разобраться, что на самом деле мотивирует сотрудников оставаться в компании и быть лояльными\u003C\u002Fp\u003E\u003Cp\u003EВместе прошли по тернистому пути к лояльности, опросив&nbsp;3 000+ сотрудников, HR и руководителей из разных отраслей:&nbsp;от ретейла и логистики до IT и промышленности. Мы заботливо собрали самые разные мнения, чтобы понять, что по-настоящему важно для людей, которые остаются в компании надолго и любят свою работу. \u003C\u002Fp\u003E\u003Cp\u003EНаша цель проста — помочь бизнесу не сливать бюджет на бесполезные инициативы, а сотрудникам — получать то, что им действительно нужно. \u003C\u002Fp\u003E\u003Cp\u003EПриглашаем вас на офлайн-презентацию в Москве в марте. Обсудим результаты исследования, ключевые выводы и разберем, как строить эффективные Retention-стратегии в 2025 году.\u003C\u002Fp\u003E\u003Cp\u003EКоличество мест ограничено, заявки проходят модерацию. Если ваша заявка будет одобрена, вы получите письмо с подтверждением и адресом встречи.\u003C\u002Fp\u003E\u003Cp\u003EЕсли прийти не получится — после ивента отправим результаты исследования всем, кто зарегистрируется на лендинге.\u003C\u002Fp\u003E\u003Cp\u003EМентальное здоровье сотрудников — важная часть корпоративной культуры. В «Ясно для бизнеса» изучают, как забота о команде влияет на вовлечённость и эффективность. Они подготовили гайд о работе с молодыми специалистами, а для теста сервиса есть промокод CORP-HABRTLNT-DISC20 на скидку 20% для первых сессий: https:\u002F\u002Fu.habr.com\u002FPQP4b\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb14\u002Fcd3\u002F772\u002Fb14cd3772bc67698c8fbfd846e23824a.png","eventUrl":"https:\u002F\u002Fevent.k-team.ru\u002Fexpectations_vs_reality?utm_source=habr","startDay":"2025-03-20","startTime":"10:00","finishDay":"2025-03-20","finishTime":"17:00","isOnline":false,"geo":["Москва"],"isArchive":false,"categories":[{"id":"16","titleHtml":"Другое"}],"tags":["HR","HRD","Удержание сотрудников"],"metadata":null},{"id":"604","titleHtml":"IX HappyWorkForum | Аутентичность и ментальное здоровье персонала","descriptionHtml":"\u003Cp\u003EБолее 250 HRD, первые лица компаний и владельцы крупного бизнеса обсудят лучшие практики благополучия и управление командой.\u003C\u002Fp\u003E\u003Cp\u003EПочему ментальное здоровье становится KPI бизнеса?\u003C\u002Fp\u003E\u003Cp\u003EГде граница ответственности за выгорание и стресс сотрудников?\u003C\u002Fp\u003E\u003Cp\u003EКак стать работодателем №1?\u003C\u002Fp\u003E\u003Cp\u003EКак управлять уставшими командами?\u003C\u002Fp\u003E\u003Cp\u003EКак справляться с выгоранием руководителей?\u003C\u002Fp\u003E\u003Cp\u003EЧем замотивировать сотрудников, когда деньги уже не работают?&nbsp;&nbsp;\u003C\u002Fp\u003E\u003Cp\u003EКак решать ценностные конфликты?\u003C\u002Fp\u003E\u003Cp\u003EУспешные корпоративные программы: что реально работает?&nbsp;&nbsp;\u003C\u002Fp\u003E\u003Cp\u003EВ программе презентация отчёта по развитию лидерства, батлы, практические кейсы и нетворкинг.\u003C\u002Fp\u003E\u003Cp\u003EСреди спикеров, представители компаний: Т-банк, Сравни.ру, Ростелеком, ТД Ренна, Спортмастер, ТрансТелеком, Оптиком, Норникель, Азбука вкуса, ЕВМ и другие.\u003C\u002Fp\u003E\u003Cp\u003EУчастие для HRD, руководителей и владельцев бизнеса без оплаты. Действует строгая модерация.\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F733\u002F9ef\u002F194\u002F7339ef1945f3ee6906daf89db79829d4.png","eventUrl":"https:\u002F\u002Fhappyforum.ru\u002F?utm_source=habr&utm_medium=email&utm_campaign=hwf","startDay":"2025-03-20","startTime":"10:00","finishDay":"2025-03-20","finishTime":"18:00","isOnline":true,"geo":["Москва"],"isArchive":false,"categories":[{"id":"16","titleHtml":"Другое"}],"tags":["HRD","HR"],"metadata":null},{"id":"612","titleHtml":"Вебинар «Мастерская бюджета: как управлять затратами на облачные ресурсы»","descriptionHtml":"\u003Cp\u003EРасскажем, как сэкономить на использовании облачных сервисов через возможности личного кабинета, сервисы с free tier и акции. Покажем, как оптимизировать потребление ресурсов и настроить лимиты бюджетов.\u003C\u002Fp\u003E\u003Cp\u003EПрограмма вебинара:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EАнализ текущей утилизации ресурсов: поиск ресурсов с низкой утилизацией и анализ возможной оптимизации.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКалькулятор затрат: демо-настройки параметров для точных прогнозов расходов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EАнализ детализированных данных: подходы к аналитике, включая метаданные.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОптимизация потребления: использование зарезервированных инстансов и спотовых экземпляров.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EАнализ бесплатного потребления: как использовать free tier для сокращения затрат.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EНастройка лимитов бюджетов: автоматизация и уведомления для контроля расходов.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EИспользование Public API: тегирование ресурсов для лучшей аналитики затрат.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВебинар будет интересен менеджерам облачных ресурсов и IT-департаментов, DevOps-инженерам и сотрудникам, в чью зону ответственности входит контроль над облачными расходами.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F38f\u002F10d\u002Ff4c\u002F38f10df4c7f9d7c5d4610fe426af0ab4.png","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_cloudeventwebinar","startDay":"2025-03-20","startTime":"11:00","finishDay":"2025-03-20","isOnline":true,"geo":[],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"},{"id":"4","titleHtml":"Администрирование"}],"tags":["вебинар cloudru","вебинар для айтишников","вебинар про облака"],"metadata":null},{"id":"616","titleHtml":"Бизнес-конференция «Digital Brand Day 2025: Орбита 2025»","descriptionHtml":"\u003Cp\u003E21 марта конференция «Digital Brand Day 2025: Орбита 2025» в восьмой раз соберёт ведущих экспертов цифрового маркетинга и рекламы для обсуждения главных трендов digital-рынка и новых инструментов, которые определят стратегию брендов.\u003C\u002Fp\u003E\u003Cp\u003EВ основе темы Digital Brand Day 2025 лежит фундаментальный вопрос философии: что первично — материя или сознание? А что же первично в цифровой среде — технологии или идеи? Конференция станет эпицентром открытий, где мы вместе проложим путь сквозь бескрайние просторы рекламного космоса и наметим вектор развития цифрового маркетинга.\u003C\u002Fp\u003E\u003Cp\u003EГостей «Digital Brand Day: Орбита 2025» ждёт не только насыщенная программа, но и возможность завести полезные знакомства, увидеть, каким будет диджитал завтра.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F523\u002F7fb\u002F13a\u002F5237fb13ad7fb6fb483c49691aaec836.png","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_digitalbrandday","startDay":"2025-03-21","startTime":"10:00","isOnline":false,"geo":["Москва"],"isArchive":false,"categories":[{"id":"10","titleHtml":"Маркетинг"},{"id":"16","titleHtml":"Другое"}],"tags":["digital brand day","бизнес-конференция digital brand day","цифровой маркетинг","digital-рынок"],"metadata":null},{"id":"608","titleHtml":"Вебинар «Контент-маркетинг здорового человека: как привлечь внимание аудитории»","descriptionHtml":"\u003Cp\u003E27 марта в 16:00 МСК вместе с агентством Loft PR Studio проведем открытый вебинар о том, как писать про здоровье на Хабре. \u003C\u002Fp\u003E\u003Cp\u003EНа вебинаре разберем, что помогает удерживать внимание и превращает контент в работающий инструмент. Поделимся опытом брендов, которые ведут блоги и регулярно публикуют статьи.\u003C\u002Fp\u003E\u003Cp\u003EБудет интересно тем, кто продвигает товары и услуги для здоровья на аудиторию B2C и B2B. \u003C\u002Fp\u003E\u003Cp\u003E🔗 Участие бесплатное, но нужна предварительная регистрация.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F8fd\u002Fe04\u002Fddd\u002F8fde04ddd9ba3f6bcd515aa6209f96b7.png","eventUrl":"https:\u002F\u002Fhabr.timepad.ru\u002Fevent\u002F3266126\u002F?utm_refcode=b5d44b4f1d5f2c06b5696586408b58e610baafd8","startDay":"2025-03-27","startTime":"16:00","finishDay":"2025-03-27","finishTime":"18:00","isOnline":true,"geo":[],"isArchive":false,"categories":[{"id":"10","titleHtml":"Маркетинг"},{"id":"16","titleHtml":"Другое"}],"tags":["Вебинар","Контент","Хабр"],"metadata":null},{"id":"606","titleHtml":"Серия вебинаров «DevOps Middle: AvitoTech vs ecom.tech»","descriptionHtml":"\u003Cp\u003EУчебный центр Слёрм запустил серию бесплатных вебинаров «Честные вакансии: DevOps Middle».\u003C\u002Fp\u003E\u003Cp\u003EДва раза в неделю Вячеслав Федосеев, TeamLead DevOps в «Честном знаке» и автор телеграм-канала «DevOps Bootcamp с Федосеевым» встречается в прямом эфире с экспертами из бигтеха, чтобы обсудить:\u003C\u002Fp\u003E\u003Col\u003E\u003Cli\u003E\u003Cp\u003EКакие задачи должен решать DevOps middle.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКакими основными и дополнительными инструментами и подходами должен владеть DevOps middle.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EСтоп-факторы на собеседовании.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКак выглядит рабочий день DevOps middle.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКакие софт-скилы действительно важны.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\u003Cp\u003E31 марта состоится встреча с экспертами AvitoTech, 2 апреля — с ecom.tech. Кому подходите вы, а кто — вам? Разберёмся вместе на вебинарах.\u003C\u002Fp\u003E\u003Cp\u003EПодробности — в telegram-боте.\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Fb99\u002F62a\u002Fb24\u002Fb9962ab2439c6edc80f96d7f0a847c72.png","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_slermdevops","startDay":"2025-03-31","startTime":"17:00","isOnline":true,"geo":[],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"},{"id":"4","titleHtml":"Администрирование"}],"tags":["Вебинар Слерм","Вебинар Devops","Честные вакансии","Слерм","Честные вакансии Devops Middle"],"metadata":null},{"id":"618","titleHtml":"Реалити для разработчиков: узнайте, как строится новое публичное облако MWS","descriptionHtml":"\u003Cp\u003EBuilding the Cloud — это реалити-проект для разработчиков о новом облаке МТС Web Services. Каждый эпизод посвящён отдельному building-блоку новой облачной платформы.\u003C\u002Fp\u003E\u003Cp\u003EВ прямом эфире:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EПоказываем архитектуру сервисов облака ещё до релиза.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EДелимся опытом на реальных кейсах из разработки.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EОтвечаем на вопросы в прямом эфире.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EВ новом выпуске проекта расскажем, как строим underlay-сеть нового облака.\u003C\u002Fp\u003E\u003Cp\u003EВы узнаете:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EКак мы поменяли подход к построению underlay-сети в новом облаке MWS.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКакую архитектуру строим и как реализовали изоляцию management и data plane.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EКак обеспечиваем отказоустойчивость и производительность на уровне физической инфраструктуры.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EНовый выпуск Building the Cloud будет интересен сетевым инженерам, backend-разработчикам, DevOps- и SRE-инженерам, а также всем, кто интересуется сетевыми или облачными технологиями.\u003C\u002Fp\u003E\u003Cp\u003EРегистрируйтесь по ссылке, подключайтесь к прямому эфиру и задавайте вопросы в чате.\u003C\u002Fp\u003E\u003Cp\u003EЗа самый интересный вопрос подарим фирменный мерч MWS.\u003C\u002Fp\u003E\u003Cp\u003EДо встречи в эфире.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Ff76\u002F0f9\u002Fa82\u002Ff760f9a827b851a5eeca4802c643a91d.png","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_buildingthecloud4","startDay":"2025-04-03","startTime":"11:00","isOnline":true,"geo":[],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"}],"tags":["реалити-проект для разработчиков","Реалити для разработчиков","облако","облако MWS"],"metadata":null},{"id":"620","titleHtml":"Открытая встреча «System Analysis Meetup SberHealth»","descriptionHtml":"\u003Cp\u003EВ программе:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EГоргоц Мария, старший системный аналитик, расскажет про описание требований для мобильных приложений.&nbsp;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EНижник Станислав, ведущий системный аналитик, расскажет про книжный клуб системных аналитиков: «Как мы создали сообщество для обмена знаниями».\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EВ качестве приглашённого спикера Севостьянова Анастасия, ведущий системный аналитик в Альфа-Банке, расскажет про мидл слой без хаоса: «Как сделать документацию понятной и живой».&nbsp;\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EПосле сессии с докладами проведём профессиональную игру для офлайн-участников «Искусство защиты абсурда».&nbsp;\u003C\u002Fp\u003E\u003Cp\u003EВедущая митапа Пашкова Ольга, руководитель направления методологии и системного анализа в СберЗдоровье.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002Feba\u002Fc37\u002F879\u002Febac378793b959ebce42f41713e7b67f.jpg","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_sbermeetup","startDay":"2025-04-03","startTime":"17:00","finishDay":"2025-04-03","finishTime":"23:00","isOnline":true,"geo":["Москва"],"isArchive":false,"categories":[{"id":"12","titleHtml":"Аналитика"}],"tags":["Семинар аналитика","сбер митап","системная аналитика митап","системная аналитика"],"metadata":null},{"id":"590","titleHtml":"«GoCloud 2025» — масштабная IT-конференция про облака и AI","descriptionHtml":"\u003Cp\u003EПоговорим про глобальные тренды в AI, расскажем про широкий набор сценариев работы в облаке, поделимся последними релизами и нашими планами, чтобы показать, какой простор открывают облачные и AI-технологии для бизнеса и разработчиков.\u003C\u002Fp\u003E\u003Cp\u003EЧто ждёт участников в этом году:\u003C\u002Fp\u003E\u003Cul\u003E\u003Cli\u003E\u003Cp\u003EТри трека: инфраструктура и инструменты, AI и R&amp;D и сценарии работы в облаке.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003E30+ спикеров из Cloud.ru и ведущих российских компаний.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003ELive-демонстрации облачных платформ и нетворкинг с экспертами.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003Cli\u003E\u003Cp\u003EНе только доклады: интерактивные зоны, afterparty с музыкальной программой и кастомный мерч.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003Cp\u003EКому будет полезно: техническим лидерам, IT-директорам, бизнес-руководителям, разработчикам, DevOps-инженерам, архитекторам, дата-инженерам, AI\u002FML-инженерам, дата-сайентистам, SRE-инженерам, системным администраторам, специалистам по информационной безопасности.\u003C\u002Fp\u003E\u003Cp\u003EАдрес: Москва, Цифровое деловое пространство (ЦДП), ул. Покровка, 47.\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F31b\u002Fe68\u002F295\u002F31be6829578e7934fbc944396eb330b1.png","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_gocloud","startDay":"2025-04-10","startTime":"10:00","finishDay":"2025-04-10","finishTime":"20:00","isOnline":true,"geo":["Москва"],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"},{"id":"4","titleHtml":"Администрирование"},{"id":"8","titleHtml":"Менеджмент"}],"tags":["конференция Cloud.ru","AI","ИИ","айти конференция","облачные хранилища"],"metadata":null},{"id":"516","titleHtml":"IT-конференция Merge Tatarstan 2025","descriptionHtml":"\u003Cp\u003EКрупнейшая региональная IT-конференция России собирает профессионалов со всей страны для нетворкинга, обмена опытом и поиска новых деловых контактов.\u003C\u002Fp\u003E\u003Cp\u003EMerge Tatarstan — это 7 тематических конференций на одной площадке, 2000 участников, более 170 спикеров-практиков, мастер-классы, воркшопы и BoF-сессии.\u003C\u002Fp\u003E\u003Cp\u003EК участию в конференции приглашаются разработчики, QA, тимлиды, Project\u002FProduct-менеджеры, маркетологи, аналитики, UI\u002FUX-дизайнеры, PR-специалисты, HR-менеджеры, владельцы бизнеса и начинающие специалисты.\u003C\u002Fp\u003E\u003Cp\u003E\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F0e9\u002F3a8\u002F3ec\u002F0e93a83ecea09f806d1df907ddb036a4.jpg","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_tatarstan","startDay":"2025-04-25","startTime":"09:00","finishDay":"2025-04-26","finishTime":"19:30","isOnline":false,"geo":["Казань"],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"},{"id":"10","titleHtml":"Маркетинг"},{"id":"16","titleHtml":"Другое"}],"tags":["Разработка","IT","PR","UI\u002FUX","бизнес","маркетинг","аналитика"],"metadata":null},{"id":"610","titleHtml":"Летняя айти-тусовка Summer Merge","descriptionHtml":"\u003Cp\u003EЛетняя айти-тусовка возвращается.\u003C\u002Fp\u003E\u003Cp\u003EВырваться из рутины и сменить обстановку на несколько дней можно вместе с Summer Merge.&nbsp;\u003C\u002Fp\u003E\u003Cp\u003EСосновый лес, чистый воздух, живое общение с экспертами IT, спортивные состязания, мастер-классы, квесты, встречи с друзьями, новые знакомства, afterparty — забудьте про суету города и окунитесь в приятную атмосферу digital detox. В эти летние IT-выходные мы обещаем атмосферу ярких приключений.&nbsp;\u003C\u002Fp\u003E\u003Cp\u003EЖдём вас 20—22 июня в экопарке «Русский берег» на Summer Merge.\u003C\u002Fp\u003E","imageUrl":"https:\u002F\u002Fhabrastorage.org\u002Fgetpro\u002Fhabr\u002Fupload_files\u002F652\u002F12d\u002F998\u002F65212d998fb4939d9787bd9c726d2acb.png","eventUrl":"https:\u002F\u002Fu.habr.com\u002Fcldr_summermerge","startDay":"2025-06-20","finishDay":"2025-06-22","isOnline":false,"geo":["Ульяновская область"],"isArchive":false,"categories":[{"id":"2","titleHtml":"Разработка"},{"id":"16","titleHtml":"Другое"}],"tags":["летняя айти-тусовка","айти-кэмп","летний выезд для айтишников","Summer Merge"],"metadata":null}],"currentEvent":null,"eventsFilter":{"city":"all","timeStarted":null,"timeEnded":null}},"wysiwyg":{"WYSIWYGRulesRefs":null}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="https://assets.habr.com/habr-web/js/chunk-vendors.3b11d41f.js" defer></script><script src="https://assets.habr.com/habr-web/js/app.7a97ea6d.js" defer></script></div>
    <div id="overlays"><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--><!----><!--teleport anchor--></div>
    
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-S28W1WC23F"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    </script>
  
  <script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  </script>
    <script type="text/javascript">
      window.addEventListener('load', function () {
        setTimeout(() => {
          const img = new Image();
          img.src = 'https://vk.com/rtrg?p=VK-RTRG-421343-57vKE';
        }, 0);
      });
    </script>
  
    </body>

    </html>
